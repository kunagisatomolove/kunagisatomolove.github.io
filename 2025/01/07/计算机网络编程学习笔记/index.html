<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>《TCP/IP网络编程》学习笔记 | 王建's 博客</title><meta name="author" content="王建,2200189658@qq.com"><meta name="copyright" content="王建"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="TCP&#x2F;IP网络编程 1.TCP套接字 1.1 相关函数  socket函数创建套接字 bind函数分配IP地址和端口号给套接字 listen函数，使套接字可接收客户端连接 accept函数，使其受理客户端请求 connect函数，使其从客户端发送连接请求 closesocket函数，关闭套接字  1.2 基于Windos的服务端  使用WSAStartup函数初始化套接字库(初始化Winsock">
<meta property="og:type" content="article">
<meta property="og:title" content="《TCP&#x2F;IP网络编程》学习笔记">
<meta property="og:url" content="https://kunagisatomolove.github.io/2025/01/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html">
<meta property="og:site_name" content="王建&#39;s 博客">
<meta property="og:description" content="TCP&#x2F;IP网络编程 1.TCP套接字 1.1 相关函数  socket函数创建套接字 bind函数分配IP地址和端口号给套接字 listen函数，使套接字可接收客户端连接 accept函数，使其受理客户端请求 connect函数，使其从客户端发送连接请求 closesocket函数，关闭套接字  1.2 基于Windos的服务端  使用WSAStartup函数初始化套接字库(初始化Winsock">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://kunagisatomolove.github.io/wallpaper/images/6og3lq.png">
<meta property="article:published_time" content="2025-01-07T04:03:07.000Z">
<meta property="article:modified_time" content="2025-01-22T03:11:22.228Z">
<meta property="article:author" content="王建">
<meta property="article:tag" content="C++">
<meta property="article:tag" content="Windows">
<meta property="article:tag" content="TCP&#x2F;IP">
<meta property="article:tag" content="Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://kunagisatomolove.github.io/wallpaper/images/6og3lq.png"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://kunagisatomolove.github.io/2025/01/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.css" media="print" onload="this.media='all'"><script>
    (() => {
      
    const saveToLocal = {
      set: (key, value, ttl) => {
        if (!ttl) return
        const expiry = Date.now() + ttl * 86400000
        localStorage.setItem(key, JSON.stringify({ value, expiry }))
      },
      get: key => {
        const itemStr = localStorage.getItem(key)
        if (!itemStr) return undefined
        const { value, expiry } = JSON.parse(itemStr)
        if (Date.now() > expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return value
      }
    }

    window.btf = {
      saveToLocal,
      getScript: (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        Object.entries(attr).forEach(([key, val]) => script.setAttribute(key, val))
        script.onload = script.onreadystatechange = () => {
          if (!script.readyState || /loaded|complete/.test(script.readyState)) resolve()
        }
        script.onerror = reject
        document.head.appendChild(script)
      }),
      getCSS: (url, id) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onload = link.onreadystatechange = () => {
          if (!link.readyState || /loaded|complete/.test(link.readyState)) resolve()
        }
        link.onerror = reject
        document.head.appendChild(link)
      }),
      addGlobalFn: (key, fn, name = false, parent = window) => {
        if (!false && key.startsWith('pjax')) return
        const globalFn = parent.globalFn || {}
        globalFn[key] = globalFn[key] || {}
        globalFn[key][name || Object.keys(globalFn[key]).length] = fn
        parent.globalFn = globalFn
      }
    }
  
      
      const activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      const activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }

      btf.activateDarkMode = activateDarkMode
      btf.activateLightMode = activateLightMode

      const theme = saveToLocal.get('theme')
    
          theme === 'dark' ? activateDarkMode() : theme === 'light' ? activateLightMode() : null
        
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        document.documentElement.classList.toggle('hide-aside', asideStatus === 'hide')
      }
    
      
    const detectApple = () => {
      if (/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)) {
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
  
    })()
  </script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: {"appId":"WKJ29H8QCP","apiKey":"8a3d1333693ba0935df0a97b25d14121","indexName":"blog_index","hitsPerPage":6,"languages":{"input_placeholder":"搜索文章","hits_empty":"未找到符合您查询的内容：${query}","hits_stats":"找到 ${hits} 条结果，耗时 ${time} 毫秒"}},
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false,"highlightFullpage":false,"highlightMacStyle":false},
  copy: {
    success: '复制成功',
    error: '复制失败',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'medium_zoom',
  Snackbar: {"chs_to_cht":"已切换为繁体中文","cht_to_chs":"已切换为简体中文","day_to_night":"已切换为深色模式","night_to_day":"已切换为浅色模式","bgLight":"#49b1f5","bgDark":"#1f1f1f","position":"bottom-left"},
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: true,
  islazyload: true,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '《TCP/IP网络编程》学习笔记',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  isShuoshuo: false
}</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><script>(()=>{
  const $loadingBox = document.getElementById('loading-box')
  const $body = document.body
  const preloader = {
    endLoading: () => {
      $body.style.overflow = ''
      $loadingBox.classList.add('loaded')
    },
    initLoading: () => {
      $body.style.overflow = 'hidden'
      $loadingBox.classList.remove('loaded')
    }
  }

  preloader.initLoading()
  window.addEventListener('load', preloader.endLoading)

  if (false) {
    btf.addGlobalFn('pjaxSend', preloader.initLoading, 'preloader_init')
    btf.addGlobalFn('pjaxComplete', preloader.endLoading, 'preloader_end')
  }
})()</script><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img text-center"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://thirdqq.qlogo.cn/g?b=sdk&amp;nk=2200189658&amp;s=140" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data text-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fa fa-comments"></i><span> 在线说说</span></a></li><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comment"></i><span> 本地说说</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/wallpaper/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/wallpaper/images/6og3lq.png);"><nav id="nav"><span id="blog-info"><a class="nav-site-title" href="/"><span class="site-name">王建's 博客</span></a><a class="nav-page-title" href="/"><span class="site-name">《TCP/IP网络编程》学习笔记</span></a></span><div id="menus"><div id="search-button"><span class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></span></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fa fa-graduation-cap"></i><span> 博文</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/artitalk/"><i class="fa-fw fa fa-comments"></i><span> 在线说说</span></a></li><li><a class="site-page child" href="/shuoshuo/"><i class="fa-fw fa fa-comment"></i><span> 本地说说</span></a></li><li><a class="site-page child" href="/categories/"><i class="fa-fw fa fa-archive"></i><span> 分类</span></a></li><li><a class="site-page child" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a></li><li><a class="site-page child" href="/archives/"><i class="fa-fw fa fa-folder-open"></i><span> 归档</span></a></li></ul></div><div class="menus_item"><span class="site-page group"><i class="fa-fw fas fa-list"></i><span> 生活</span><i class="fas fa-chevron-down"></i></span><ul class="menus_item_child"><li><a class="site-page child" href="/wallpaper/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a></li><li><a class="site-page child" href="/music/"><i class="fa-fw fa fa-music"></i><span> 音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> 影视</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/comment/"><i class="fa-fw fa fa-paper-plane"></i><span> 留言板</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于笔者</span></a></div></div><div id="toggle-menu"><span class="site-page"><i class="fas fa-bars fa-fw"></i></span></div></div></nav><div id="post-info"><h1 class="post-title">《TCP/IP网络编程》学习笔记</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2025-01-07T04:03:07.000Z" title="发表于 2025-01-07 12:03:07">2025-01-07</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-22T03:11:22.228Z" title="更新于 2025-01-22 11:11:22">2025-01-22</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/">计算机网络</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">总字数:</span><span class="word-count">14.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>46分钟</span></span><span class="post-meta-separator">|</span><span id="" data-flag-title=""><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">浏览量:</span><span id="twikoo_visitors"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="container post-content" id="article-container"><center>TCP/IP网络编程</center>
<h1>1.TCP套接字</h1>
<h2 id="1-1-相关函数">1.1 相关函数</h2>
<ol>
<li>socket函数创建套接字</li>
<li>bind函数分配IP地址和端口号给套接字</li>
<li>listen函数，使套接字可接收客户端连接</li>
<li>accept函数，使其受理客户端请求</li>
<li>connect函数，使其从客户端发送连接请求</li>
<li>closesocket函数，关闭套接字</li>
</ol>
<h2 id="1-2-基于Windos的服务端">1.2 基于Windos的服务端</h2>
<ol>
<li>使用WSAStartup函数初始化套接字库(初始化Winsock库)</li>
<li>调用socket函数创建套接字</li>
<li>调用bind分配IP地址和端口号给套接字</li>
<li>调用listen函数使创建的套接字成为服务端的套接字并监听套接字</li>
<li>调用accept函数受理客户端连接请求</li>
<li>调用send函数向指定客户端传输数据</li>
<li>调用closesocket函数关闭套接字</li>
<li>调用WSACleanup归还库，使程序无法调用Winsock相关函数(注销Winsock库)</li>
</ol>
<p>![套接字步骤](/home/wj/图片/截图/截图 2023-05-08 09-53-58.png)</p>
<h2 id="1-3-基于Windos的客户端">1.3 基于Windos的客户端</h2>
<ol>
<li>使用WSAStartup函数初始化套接字库(初始化Winsock库)</li>
<li>调用socket函数创建套接字</li>
<li>调用connect函数向服务端发送连接请求</li>
<li>调用recv函数接收服务端发送的数据</li>
<li>调用closesocket函数关闭套接字</li>
<li>调用WSACleanup归还库，使程序无法调用Winsock相关函数(注销Winsock库)</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/home/wj/.config/Typora/typora-user-images/image-20230508095725129.png" alt="客户端套接字创建步骤"></p>
<h2 id="1-4-套接字函数详解">1.4 套接字函数详解</h2>
<h3 id="1-4-1-socket函数">1.4.1 socket函数</h3>
<blockquote>
<p>int socket(int domain,int type,int protocol)</p>
<ol>
<li>
<p>domain 套接字使用的协议族</p>
</li>
<li>
<p>type 套接字数据传输信息</p>
<ul>
<li>
<p>面向连接的套接字 SOCK_STREAM</p>
<blockquote>
<p>可靠的，按序传递，无数据边界的传输</p>
</blockquote>
</li>
<li>
<p>面向消息的套接字 SOCK_DGRAM</p>
<blockquote>
<p>不可靠的，不按序传递，有数据边界的，高速的传输</p>
<p>存在数据边界意味着接收数据的次数和传输次数相同</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>protocol 计算机通信中使用的协议信息</p>
</li>
</ol>
</blockquote>
<h3 id="1-4-2-bind函数">1.4.2 bind函数</h3>
<blockquote>
<p>IP地址是区分电脑的，端口号是区分套接字的。</p>
<p>结构体 socketaddr_in 保存地址族，IP地址，端口号</p>
</blockquote>
<blockquote>
<p>int bind(int sockfd,struct sockaddr* myaddr,socklen_t addrlen)</p>
<ol>
<li>sockfd 要分配信息(IP地址和端口号)的套接字描述符</li>
<li>myaddr 存有地址信息的结构体变量地址值</li>
<li>addrlen 第二个结构体的长度</li>
</ol>
</blockquote>
<h3 id="1-4-3-listen函数">1.4.3 listen函数</h3>
<blockquote>
<p>int listen(int sock,int backlog);</p>
<ol>
<li>
<p>sock 希望进入等待连接请求状态的套接字描述符，使套接字成为服务端套接字</p>
<blockquote>
<p>就是让套接字工作起来，等待客户端的连接请求</p>
</blockquote>
</li>
<li>
<p>backlog 连接请求等待队列的长度，表示最多多少个连接请求进入队列</p>
</li>
</ol>
</blockquote>
<h3 id="1-4-4-accept函数">1.4.4 accept函数</h3>
<blockquote>
<p>int accept(int sock,struct sockaddr* addr,socklen_t* addrlen);</p>
<ol>
<li>socket 套接字文件描述符</li>
<li>保存发起连接请求的客户端地址信息的变量地址值，填充客户端地址信息</li>
<li>保存第二个参数结构体的长度，填充客户端地址长度</li>
</ol>
<p>accept受理等待请求队列中的请求，返回套接字，服务端将该套接字和请求的套接字连接，用以完成数据交互。（服务端创建的套接字与客户端的套接字建立连接后进行数据交换）</p>
</blockquote>
<h3 id="1-4-5-connect函数">1.4.5 connect函数</h3>
<blockquote>
<p>int connect(int sock,struct sockaddr* servaddr,socklen_t addrlen)</p>
<ol>
<li>sock 客户端套接字描述符</li>
<li>servaddr 保存目标服务器地址信息的变量地址值</li>
<li>addrlen 第二个参数的长度，单位字节</li>
</ol>
<p>客户端的IP地址和端口在调用connect函数时自动分配，无需调用标记的bind函数进行分配。</p>
</blockquote>
<h2 id="1-4-6-read函数">1.4.6 read函数</h2>
<blockquote>
<blockquote>
<p>ssize_t read(int fd, void *buf, size_t count);</p>
<p>参数：</p>
<ul>
<li>fd：文件描述符。在网络编程中，fd 为 Socket 句柄。</li>
<li>buf：指向要读取的数据的缓冲区的指针。读取的数据将被存储在此缓冲区中。</li>
<li>count：要读取的最大字节数。</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回读取的字节数。如果读取失败，则返回 -1。</li>
<li>如果已到达文件或网络的末尾，则返回 0。对于网络编程来说，它意味着另一端已关闭 Socket 连接。</li>
</ul>
</blockquote>
</blockquote>
<h2 id="1-4-7-write函数">1.4.7 write函数</h2>
<blockquote>
<blockquote>
<p>ssize_t write(int fd, const void *buf, size_t count);</p>
<p>参数：</p>
<ul>
<li>fd：文件描述符。在网络编程中，fd 为 Socket 句柄。</li>
<li>buf：指向要发送的数据的缓冲区的指针。</li>
<li>count：要发送的最大字节数。</li>
</ul>
<p>返回值：</p>
<ul>
<li>返回已写入的字节数。如果失败，则返回 -1。</li>
</ul>
</blockquote>
</blockquote>
<h1>2.UDP套接字</h1>
<blockquote>
<p>UDP套接字是面向消息的套接字，其性能大部分情况下大于TCP,但是可靠性不如TCP。</p>
<p>​	1.UDP中的服务器端和客户端没有连接</p>
<p>​	2.UDP服务器和客户端均只需一个套接字</p>
<p>UDP不同于TCP,不存在请求连接和受理过程，因此在某种意义上无法明确区分服务端和客户端。</p>
</blockquote>
<h2 id="2-1-基于UDP的数据I-O函数">2.1 基于UDP的数据I/O函数</h2>
<h3 id="2-1-1-sendto函数">2.1.1 sendto函数</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">const</span> <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,<span class="type">const</span> <span class="keyword">struct</span> sockaddr *dest_addr, <span class="type">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数说明：</p>
<ul>
<li>sockfd：标识一个已连接套接字的描述符或非连接套接字的描述符。</li>
<li>buf：包含发送数据的缓冲区地址。</li>
<li>len：发送数据的字节数。</li>
<li>flags：调用操作方式,没有传递0。</li>
<li>dest_addr：指向目的套接字地址的指针。</li>
<li>addrlen：目标结构体长度的地址。</li>
</ul>
<p>函数返回值表示发送数据成功的字节数，如果出错则返回-1。</p>
<p>此函数用于UDP协议，可以将数据包发送到指定地址。如果需要发送时有对应的源地址，可以先使用bind函数绑定本地地址，然后再使用sendto函数发送数据报。</p>
</blockquote>
<h3 id="2-1-2-recvfrom函数">2.1.2 recvfrom函数</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="type">int</span> sockfd, <span class="type">void</span> *buf, <span class="type">size_t</span> len, <span class="type">int</span> flags,<span class="keyword">struct</span> sockaddr *src_addr, <span class="type">socklen_t</span> *addrlen)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数说明：</p>
<ul>
<li>sockfd：标识一个已连接套接字的描述符或非连接套接字的描述符。</li>
<li>buf：保存接收数据的缓冲区地址。</li>
<li>len：接收数据的字节数。</li>
<li>flags：调用操作方式,没有传递0。</li>
<li>src_addr：返回发送端的套接字地址。</li>
<li>addrlen：发送端结构体长度的地址。</li>
</ul>
<p>函数返回值表示接收的字节数，如果出错则返回-1。</p>
<p>此函数用于UDP协议，可以从指定的端口接收数据报。使用recvfrom函数需要注意，要事先开辟一个足够大的缓冲区来存放接收的数据报，否则数据报会被截断，导致数据的丢失。</p>
</blockquote>
<h2 id="2-2-已连接（connected）UDP套接字与未连接（unconnected）UDP套接字">2.2 已连接（connected）UDP套接字与未连接（unconnected）UDP套接字</h2>
<blockquote>
<p>1.未连接套接字：每次调用sendto函数都会变更目标地址，因此可以重复利用同UDP套接字向不同目标传输数据(目标地址不固定)</p>
<p>2.已连接套接字:目标地址已固定</p>
<p>​	UDP套接字默认属于未连接套接字。</p>
</blockquote>
<h1>3.基于TCP的半关闭</h1>
<h2 id="3-1相关函数">3.1相关函数</h2>
<h3 id="3-1-1-shutdown函数">3.1.1 shutdown函数</h3>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sockettl.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">shutdown</span><span class="params">(<span class="type">int</span> sock,<span class="type">int</span> howto)</span></span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>​		成功时返回0,失败时返回-1.</p>
<pre><code>1. sock 需要断开的套接字文件描述符

2. howto 传递断开方式信息

   * SHUT_RD:断开输入流(无法接收数据)

   * SHUT_WR:断开输出流(无法传输数据)
   * SHUT_RDWR:同时断开I/O流
</code></pre>
</blockquote>
<p>为什么需要半关闭？</p>
<blockquote>
<p>套接字A向套接字B传输数据，传输完毕，在传输的同时套接字B也向套接字A传输了数据，如果套接接字A传输完数据时就关闭了连接，导致无法接收套接字B传输的数据。</p>
</blockquote>
<h1>4套接字的多种可选项</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/home/wj/.config/Typora/typora-user-images/image-20230605164642919.png" alt="image-20230605164642919"></p>
<h2 id="4-1getsockopt函数">4.1getsockopt函数</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/home/wj/.config/Typora/typora-user-images/image-20230605165320613.png" alt="image-20230605165320613"></p>
<h2 id="4-2setsockopt函数">4.2setsockopt函数</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/home/wj/.config/Typora/typora-user-images/image-20230605165349561.png" alt="image-20230605165349561"></p>
<blockquote>
<p>套接字类型只能在创建时决定，以后不能更改。</p>
</blockquote>
<h2 id="4-3Time-wait状态">4.3Time-wait状态</h2>
<blockquote>
<p>套接字经过四次握手过程后并非立即消除，而是经过一段时间的Time-wait状态，在TIme-wait的过程中，相应端口是正在使用的状态，不管是客户端还是服务端，先断开连接的套接字必然经过Time-wait过程，但无需考虑客户端套接字的端口号，因为客户端的套接字是随机，任意指定的。与服务端不同，客户端每次运行程序时都会动态分配端口号。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/home/wj/.config/Typora/typora-user-images/image-20230608090205296.png" alt="image-20230608090205296"></p>
<h2 id="4-4为什么会有Time-wait状态">4.4为什么会有Time-wait状态</h2>
<blockquote>
<p>​	如果主机B未能接收到主机A的SEQ为5001的消息，会认为自己刚才发送的SEQ7501消息未能抵达主机A,会试图重传，如果主机A没有Time-wait，此时主机A已是处于完全终止状态，因此主机B永远无法接收到从主机A发送来的消息。</p>
<p>​	相反，如果主机A的套接字处于Time-wait状态，则会向主机B重传最后的ACK消息。</p>
</blockquote>
<h2 id="4-5Nagle算法">4.5Nagle算法</h2>
<blockquote>
<p>Nagle算法是一种优化TCP传输效率的算法，它可以减少网络中出现的小数据包数量，从而提高网络传输效率。然而，在某些应用场景下，禁用Nagle算法可能会更有利。</p>
<p>禁用Nagle算法的主要应用场景包括：</p>
<ol>
<li>实时性要求较高的数据传输。在某些实时性要求非常高的应用中，如视频会议、在线游戏等，应该尽可能地减少数据传输的延迟。禁用Nagle算法可以减少数据传输的延迟，提高实时性。</li>
<li>大数据传输。在需要传输大文件或大数据块的应用中，禁用Nagle算法可以减少传输过程中的延迟，并提高传输效率。</li>
<li>高并发的网络应用。在高并发的网络应用中，传输数据的延迟可能会导致网络拥塞，而禁用Nagle算法可以减少网络拥塞的可能性，提高网络传输效率。</li>
</ol>
<p>总之，禁用Nagle算法通常适用于那些需要更高网络传输效率或更低延迟的应用场景。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/home/wj/.config/Typora/typora-user-images/image-20230608171651926.png" alt="image-20230608171651926"></p>
<h1>5.多进程服务器</h1>
<blockquote>
<p>进程:占用内存空间的正在运行的程序</p>
</blockquote>
<p>fork函数是Unix及类Unix操作系统中的一个系统调用，用于创建一个新的进程，这个新进程是原进程的副本。具体来说，fork函数会复制原进程的地址空间和资源，包括代码段、数据段、堆栈、文件描述符等，并将其作为新进程的地址空间和资源。新进程的唯一不同是其进程ID和父进程ID不同于原进程。</p>
<p>这种方式适用于需要在一个进程中创建子进程的场景，常见的例子包括多进程并行处理、进程间通信、守护进程等。</p>
<p>在C语言中，fork函数的原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>其中pid_t是一个标准类型，表示进程ID。fork函数的返回值有以下三种情况：</p>
<ul>
<li>父进程中，返回子进程的pid。</li>
<li>子进程中，返回0。</li>
<li>如果出现错误，返回-1。</li>
</ul>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/home/wj/.config/Typora/typora-user-images/image-20230612105047979.png" alt="image-20230612105047979"></p>
<p>另外，两个进程都将执行fork函数调用后的语句(准确地说是在fork函数返回后)。复制正在运行的，调用fork函数的进程，从复制发生点开始复制所有资源，子进程从复制发生点开始执行。</p>
<h2 id="5-1子进程的销毁">5.1子进程的销毁</h2>
<blockquote>
<p>​	进程完成工作后(执行完main函数的进程后)应被销毁，但有时这些进程将被变成僵尸进程，占用系统中的重要资源。</p>
<p>​	向exit函数传递的参数值和main函数的return语句返回的值都会传递给操作系统，而操作系统不会销毁子进程，直到把这些值传递给产生子进程的父进程。处在这种状态下的进程就是僵尸进程。(子进程调用exit函数或return值后，未将这些值返回给父进程，在这段时间这种状态的进程被称为僵尸进程)</p>
</blockquote>
<p>​	<strong>应该向创建子进程的父进程传递子进程的exit参数值或return语句的返回值。为了销毁子进程，父进程应主动请求子进程的返回值</strong></p>
<h3 id="5-1-1利用wait函数">5.1.1利用wait函数</h3>
<p><code>	wait()</code>函数会将调用进程挂起，直到其任意一个子进程退出或者接收到一个信号为止，<code>wait()</code>函数是用来等待子进程退出并检查其退出状态的一个系统调用，wait函数会阻塞当前进程，从而降低了系统资源的使用效率。</p>
<p><code>wait()</code>是一个系统调用函数，用于等待子进程终止并检查其退出状态。它有以下两种形式：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *wstatus)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *wstatus, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><code>wait()</code>函数会暂时挂起调用进程的执行，直到它的子进程终止为止,如果没有已终止的子进程，程序会一直阻塞。该函数返回终止进程的进程ID，如果是子进程就返回0。</p>
</li>
<li>
<p><code>waitpid()</code>函数则指定需要等待的子进程的进程ID，而不是等待任何子进程。它提供了更大的灵活性，因此更常用。该函数返回的PID检查子进程的状态。该函数返回终止进程的进程ID，如果是子进程就返回0。</p>
</li>
</ul>
<p>参数说明：</p>
<ul>
<li>
<p>pid：指定需要等待的子进程的PID。当pid为-1时表示等待任何一个子进程，和wait()函数的作用一样。</p>
</li>
<li>
<p>wstatus：表示子进程的退出状态。</p>
<p>此参数指向的单元中还包含其他信息，因此需要通过以下列宏进行分离</p>
<ul>
<li>WIFEXITED子进程正常终止时返回“真”(True)</li>
<li>WEXITSTATUS返回子进程的返回值</li>
</ul>
</li>
<li>
<p>options：指定等待选项，其中常用的值有WNOHANG和WUNTRACED。WNOHANG，即使没有终止的子进程也不会进入阻塞状态，而是返回0并退出函数。</p>
</li>
</ul>
<p>当子进程成功执行完毕时，会返回0。如果子进程被信号中断，wait()/waitpid()返回-1并设置errno为EINTR。如果调用进程没有子进程，则wait()/waitpid()返回-1并设置errno为ECHLD。</p>
<p>需要注意的是，wait()/waitpid()只能等待直接子进程的终止，不能等到孙子进程等后代进程的终止。如果需要等待某个进程及其后代进程的终止，可以使用<code>pid_t wait4(pid_t pid, int *wstatus, int options, struct rusage *rusage)</code>。</p>
<h2 id="5-2信号处理">5.2信号处理</h2>
<p>​	信号是在特定事件发生时由操作系统向进程发送的信息。为了响应消息，执行与消息相关的自定义操作的过程称为“处理”或“信号处理”。</p>
<h3 id="5-2-1信号与signal函数">5.2.1信号与signal函数</h3>
<p>在C语言中，<code>signal()</code>函数是用于处理信号的函数之一，其函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> (*signal(<span class="type">int</span> sig, <span class="type">void</span> (*func)(<span class="type">int</span>)))(<span class="type">int</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>SIGALRM:已到通过调用alarm函数注册的时间</li>
<li>SIGINT:输入CTRL+C</li>
<li>SIGCHLD:子进程终止</li>
</ul>
<p>其中，<code>sig</code>是要设置处理程序的信号编号，<code>func</code>是当接收到该信号时要执行的处理函数的指针。</p>
<p><code>signal()</code>函数的主要功能是设置信号处理程序。当程序接收到一个信号时，操作系统会执行在该信号上注册的处理程序。通过调用<code>signal()</code>函数，可以在程序中注册对特定信号的处理程序。</p>
<p>这个函数会返回一个函数指针，它指向先前注册的信号处理函数。可以使用该指针来恢复先前的处理程序。</p>
<p>需要注意的是，<code>signal()</code>函数在不同的操作系统中的实现和使用方式可能会有一些不同。因此，在编写跨平台程序时，需要对<code>signal()</code>函数的使用进行适当的测试和验证。</p>
<blockquote>
<p>此函数相当于“注册信号”过程，即进程发现自己的子进程结束时，请求操作系统调用特定函数。该请求通过以上函数调用完成(因此称此函数为信号注册函数)。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">__sighandler_t</span> <span class="title function_">signal</span> <span class="params">(<span class="type">int</span> __sig, <span class="type">__sighandler_t</span> __handler)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>该函数的返回值是之前与所述信号相关联的信号处理函数的指针，或者如果信号未曾注册过信号处理函数，返回SIG_DFL或SIG_IGN中的一个。SIG_DFL表示默认的信号处理函数，SIG_IGN表示忽略信号不做处理。</p>
</blockquote>
<h3 id="5-2-2alarm函数">5.2.2alarm函数</h3>
<p>在C语言中，<code>alarm()</code>函数用于设置闹钟定时器，其函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">alarm</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> seconds)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数将在指定的秒数后向程序发送<code>SIGALRM</code>信号，以触发该信号的处理程序。如果在调用<code>alarm()</code>函数之前已经设置了闹钟定时器，则新的调用将会覆盖先前的设置，并将剩余时间替换为新指定的时间。</p>
<p>如果指定秒数为0，则闹钟定时器的计时器将被清除，这可以用于取消之前设置的定时器并停止任何已挂起的闹钟。</p>
<p><code>alarm()</code>函数返回一个无符号整数值，表示之前设置的闹钟定时器剩余的时间（以秒为单位）。如果没有先前设置的闹钟，则返回0。</p>
<p>如果通过该函数预约信号后未指定该信号对应的处理函数，则(通过调用signal函数)终止进程，不做任何处理。</p>
<blockquote>
<p><em>发生信号时将唤醒由于调用sleep函数而进入阻塞状态的进程。</em></p>
</blockquote>
<h3 id="5-2-3sigaction函数">5.2.3sigaction函数</h3>
<p><code>sigaction()</code> 是 C 语言中用来处理信号的函数，它可以用来安装信号处理器、检查或改变信号的处理方式等。其函数原型为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">sigaction</span><span class="params">(<span class="type">int</span> signum, <span class="type">const</span> <span class="keyword">struct</span> sigaction *act, <span class="keyword">struct</span> sigaction *oldact)</span>;</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>signum</code>：要操作的信号的编号；</li>
<li><code>act</code>：一个指向 sigaction 结构的指针，用来指定信号处理的新动作；</li>
<li><code>oldact</code>：一个指针，用于存储之前的信号处理动作。</li>
</ul>
<p>其中 <code>sigaction</code> 结构定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sigaction</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> (*sa_handler)(<span class="type">int</span>);</span><br><span class="line">    <span class="type">void</span> (*sa_sigaction)(<span class="type">int</span>, <span class="type">siginfo_t</span> *, <span class="type">void</span> *);</span><br><span class="line">    <span class="type">sigset_t</span> sa_mask;</span><br><span class="line">    <span class="type">int</span> sa_flags;</span><br><span class="line">    <span class="type">void</span> (*sa_restorer)(<span class="type">void</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中的字段含义如下：</p>
<ul>
<li><code>sa_handler</code>：信号处理函数的地址，也可以指定 SIG_IGN 或 SIG_DFL 参数表示忽略或采用系统默认处理方式；</li>
<li><code>sa_sigaction</code>：可选的信号处理函数，在 <code>sa_handler</code> 为 NULL 时使用；</li>
<li><code>sa_mask</code>：指定在执行信号处理函数时需要阻塞的信号集合；</li>
<li><code>sa_flags</code>：指定信号的处理方式选项，例如 SA_RESTART 表示在信号中断的情况下自动重启被中断的系统调用，SA_SIGINFO 表示使用 <code>sa_sigaction</code> 处理函数；</li>
<li><code>sa_restorer</code>：已弃用。</li>
</ul>
<p><code>sigaction()</code> 函数在成功时返回 0，出错时返回 -1。通过参数 <code>oldact</code> 保存之前的信号处理方式，可以方便地在完成自定义信号处理后恢复到原先的信号处理方式。</p>
<h3 id="5-2-4复制文件描述符的问题">5.2.4复制文件描述符的问题</h3>
<blockquote>
<p>子进程复制父进程所有资源，子进程复制了父进程的文件描述符以后，父子进程的文件描述符都指向同一个套接字，只有跟指向套接字的所有文件描述符都终止(销毁)以后，才能销毁套接字，因此要将无关的套接字文件描述符关掉。这样才能正确关闭套接字。</p>
</blockquote>
<h2 id="5-3进程间的通信">5.3进程间的通信</h2>
<blockquote>
<p>进程间通信意味着两个不同进程间可以交换数据，为了完成这一点，操作系统中应该提供两个进程可以同时访问的内存空间。</p>
</blockquote>
<h1>6.I/O复用</h1>
<h2 id="6-1-Select函数">6.1 Select函数</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/home/wj/.config/Typora/typora-user-images/image-20230624145149910.png" alt="image-20230624145149910"></p>
<p>在fd_set变量中注册或更改值的操作都有下列宏完成。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/home/wj/.config/Typora/typora-user-images/image-20230624145612332.png" alt="image-20230624145612332"></p>
<p><code>select</code>函数是用于在多个可读文件流中等待输入的函数，可以监视多个文件描述符。它可以用于同时<strong>监视键盘输入和网络连接</strong>等多个文件描述符。当其中任意一个文件描述符有数据可读时，<code>select</code>函数就会返回。其函数原型为：</p>
<p><strong>FD_ISSET（）判断对应事件是否发生</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/select.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">select</span><span class="params">(<span class="type">int</span> nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, <span class="keyword">struct</span> timeval *timeout)</span>;</span><br></pre></td></tr></table></figure>
<p>参数解释如下：</p>
<ul>
<li><code>nfds</code>：值为待监视的文件描述符最大值加1，比如在<code>readfds</code>和<code>writefds</code>中都有文件描述符 0、1、2 时，传入值为 3。因为文件描述符的值是从0开始。</li>
<li><code>readfds</code>：将所有关注“是否存在待取数据”的文件描述符注册到fd_set型变量，并传递其地址值。</li>
<li><code>writefds</code>：将所有关注“是否可传输无阻塞数据”的文件描述符注册到fd_set型变量，并传递其地址值。</li>
<li><code>exceptfds</code>：将所有关注“是否发生异常”的文件描述符注册到fd_set型变量，并传递其地址值。</li>
<li><code>timeout</code>：调用select函数后，为防止陷入无限阻塞的状态，传递超时(time-out)信息。</li>
<li>返回值 ：发生错误时返回-1,超时返回时返回0。因发生关注的事件返回时，返回大于0的值。<strong>需要注意的是，返回值并不能告诉我们具体是哪些文件描述符发生变化，所以我们需遍历所有可能的文件描述符进行检查。</strong></li>
<li><code>fd_set</code>是一个数据结构，通常用于在程序中控制多个文件描述符或套接字。它是一个位数组，每个元素代表一个文件描述符或套接字。在使用<code>select</code>函数时，需要使用<code>fd_set</code>来指定需要监视的文件描述符或套接字，并检查这些文件描述符或套接字中是否有数据可读或是否可以写入数据。<code>fd_set</code>使用宏来设置和清除位，例如<code>FD_SET</code>和<code>FD_CLR</code>。</li>
</ul>
<h1>7多种I/O函数</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/home/wj/.config/Typora/typora-user-images/image-20230702144343020.png" alt="image-20230702144343020"></p>
<p>​	MSG_OOB:发送紧急消息</p>
<h2 id="7-1-fcntl函数">7.1 fcntl函数</h2>
<p>fcntl函数（File Control）是一个用于操作文件描述符的函数，它可以改变文件描述符的属性。在UNIX系统中，文件描述符是一个非负整数，用于标识打开的文件或套接字。</p>
<p>fcntl函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">fcntl</span><span class="params">(<span class="type">int</span> fd, <span class="type">int</span> cmd, ... <span class="comment">/* arg */</span> )</span>;</span><br></pre></td></tr></table></figure>
<p>参数解释：</p>
<ul>
<li>fd：要操作的文件描述符</li>
<li>cmd：操作命令，指定要执行的操作</li>
<li>arg：操作命令的参数，根据不同的操作命令而变化</li>
</ul>
<p>fcntl函数主要用于以下几种操作：</p>
<ol>
<li>
<p>复制文件描述符（F_DUPFD、F_DUPFD_CLOEXEC）：这两个命令用于复制一个文件描述符，并返回新的文件描述符。F_DUPFD命令可以指定一个最小的新文件描述符值，如果新描述符已经被占用，则向上搜索直到找到空闲的描述符。F_DUPFD_CLOEXEC命令与F_DUPFD类似，但同时将新文件描述符设置为close-on-exec，即在执行exec族函数时自动关闭这个文件描述符。</p>
</li>
<li>
<p>获取/设置文件描述符标志（F_GETFD、F_SETFD）：F_GETFD命令用于获取文件描述符的标志，F_SETFD命令用于设置文件描述符的标志。文件描述符标志主要有两种：FD_CLOEXEC表示在执行exec族函数时关闭文件描述符，FD_NONBLOCK表示文件描述符执行非阻塞I/O操作。</p>
</li>
<li>
<p>获取/设置文件状态标志（F_GETFL、F_SETFL）：F_GETFL命令用于获取文件状态标志，F_SETFL命令用于设置文件状态标志。文件状态标志用于文件的打开模式和访问模式，常用的标志包括O_RDONLY（只读）、O_WRONLY（只写）、O_RDWR（读写）、O_CREAT（如果文件不存在则创建文件）等。</p>
</li>
<li>
<p>获取/设置异步I/O所有权（F_GETOWN、F_SETOWN）：F_GETOWN命令用于获取当前拥有异步I/O通知的进程ID，F_SETOWN命令用于设置拥有异步I/O通知的进程ID。</p>
</li>
<li>
<p>获取/设置记录锁（F_GETLK、F_SETLK、F_SETLKW）：F_GETLK命令用于测试文件是否可以加锁，F_SETLK命令用于设置文件锁，F_SETLKW命令与F_SETLK相似，但如果无法获得锁，则会等待。文件锁主要有共享锁（读锁）和独占锁（写锁），用于进程间对文件的互斥访问。</p>
</li>
</ol>
<p>这些只是fcntl函数的一些常见操作，实际上还有其他一些操作命令可用。对于每个操作，参数arg的类型和含义可能不同，需要根据具体的操作而定。</p>
<p>**TCP的紧急消息无法保证消息及时送达，但可以要求提前准备消息处理函数。**换言之，紧急消息的意义在于督促信息处理，而非紧急传输形式受限的消息。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/home/wj/.config/Typora/typora-user-images/image-20230703121322808.png" alt="image-20230703121322808"></p>
<blockquote>
<p>MSG_PEEK：它使接收函数能够查看而不移除套接字接收缓冲区中的数据<br>
MSG_DONTWAIT：它用于在非阻塞模式下进行套接字操作</p>
</blockquote>
<h2 id="7-2-readv-writev函数">7.2 readv&amp;writev函数</h2>
<h3 id="7-2-1-writev函数">7.2.1 writev函数</h3>
<p>readv &amp; writev函数的功能可概括如下：</p>
<blockquote>
<p>对数据进行整合传输及发送的函数。也就是说，通过writev函数可以将分散保存在多个缓冲中的数据一并发送，通过readv函数可以由多个缓冲分别接收。因此，适当使用这两个函数可以减少I/O函数的调用次数。</p>
</blockquote>
<p><code>writev()</code> 函数是一个系统调用，用于将指定的缓冲区集合按顺序写入到文件描述符指定的文件或套接字中。它在一次系统调用中实现了连续写操作，从而提高了效率。</p>
<p><code>writev()</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">writev</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>fd</code>：文件描述符或套接字的整数表示，指示要写入的目标文件或套接字。</li>
<li><code>iov</code>：<code>iovec</code> 结构体数组，每个结构体代表一个待写入的缓冲区，包含两个字段：<code>iov_base</code> 表示缓冲区的首地址，<code>iov_len</code> 表示缓冲区的长度。</li>
<li><code>iovcnt</code>：<code>iovec</code> 结构体数组的元素个数，即待写入缓冲区的数量。</li>
</ul>
<p>返回值说明：</p>
<ul>
<li><code>writev()</code> 函数返回成功写入的字节数。如果出现错误，返回-1，并设置相应的错误代码。</li>
</ul>
<p>使用 <code>writev()</code> 函数可以将多个不连续的数据一次性写入文件，避免多次调用 <code>write()</code> 函数的开销。这对于需要将数据从不同的源写入到一个地方（如文件或网络套接字）的应用程序非常方便(<strong>将iov数组中的数据写到fd文件描述符中</strong>)。</p>
<h3 id="7-2-2-readv函数">7.2.2 readv函数</h3>
<p><code>readv()</code> 函数是一个系统调用，用于从文件描述符中读取数据到指定的缓冲区集合中。它可以一次性读取多个不连续的数据块，从而提高效率。</p>
<p><code>readv()</code> 函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">readv</span><span class="params">(<span class="type">int</span> fd, <span class="type">const</span> <span class="keyword">struct</span> iovec *iov, <span class="type">int</span> iovcnt)</span>;</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>fd</code>：文件描述符的整数表示，指示要读取数据的源文件。</li>
<li><code>iov</code>：<code>iovec</code> 结构体数组，每个结构体代表一个待读取的缓冲区，包含两个字段：<code>iov_base</code> 表示缓冲区的首地址，<code>iov_len</code> 表示缓冲区的长度。</li>
<li><code>iovcnt</code>：<code>iovec</code> 结构体数组的元素个数，即待读取缓冲区的数量。</li>
</ul>
<p>返回值说明：</p>
<ul>
<li><code>readv()</code> 函数返回成功读取的字节数。如果已到达文件末尾，返回值为0。如果出现错误，返回-1，并设置相应的错误代码。</li>
</ul>
<p>使用 <code>readv()</code> 函数可以一次性读取多个不连续的数据块，减少系统调用的次数，提高读取效率。这对于需要从不同的位置读取数据块并合并到一个缓冲区的应用程序非常方便(<strong>读取文件描述符fd中的数据放到iov数组中</strong>)。</p>
<blockquote>
<p>writev函数在不采用Nagle算法时更有价值</p>
</blockquote>
<h1>8.多播与广播</h1>
<h2 id="8-1-多播">8.1 多播</h2>
<blockquote>
<p>多播（multicast）指的是在计算机网络中，<strong>一台主机可以同时向多个目标主机发送相同的数据包</strong>。这种数据传输方式可以减小网络流量和负载，因为数据包只需要被发送一次，而不需要分别发送到每个目标主机。多播常用于视频流、音频流和实时通信等应用中。<strong>多播基于UDP完成的</strong>。</p>
<p>在多播通信中，发送方将数据包发送到一个特定的多播组地址，而接收方可以通过加入指定的多播组来接收数据。多播地址是一个特殊的IP地址，范围是<strong>224.0.0.0到239.255.255.255</strong>，其中前四位固定为1110，后面的28位可以用来标识不同的多播组。</p>
<p>在linux中注意多播的端口号必须在防火墙中放行。</p>
<p>多播是通过udp传输的</p>
<p>在多播通信中，接收套接字需要绑定到一个具体的网络接口和端口，以便能够接收到发送到该接口和端口的多播数据包</p>
<p>在接收端，接收套接字绑定的端口号应该与发送端发送的多播数据包的目标端口号一致</p>
<p>为了传递多播数据包，必须设置TTL,TTL是time to live的简写，是决定“数据包传输距离”的主要因素。</p>
</blockquote>
<h2 id="8-2-广播">8.2 广播</h2>
<blockquote>
<p>广播在一次性向多个主机发送数据这一点上与多播类似，但传输数据的范围有区别。多播即使在跨越不同网络的情况下，只要加入多播组就能接收数据。相反，广播只能向同一网络中的主机传输数据。</p>
<p>广播是向同一网络中的所有主机传输数据的方法。与多播相同，广播也是基于UDP完成的。</p>
</blockquote>
<p>根据传输数据时使用的IP地址的形式，广播分为以下两种。</p>
<ol>
<li>直接广播</li>
</ol>
<blockquote>
<p>直接广播：直接广播的IP地址中除了网络地址外，其余主机的地址全部设置为1，例如向网络地址192.12.34中的所有主机传输数据时，可以向192.12.34.255传输。因为192是C类IP地址，及子网掩码255.255.255.0,前三个是网络标识，后一个是主机标识。所有吧192.12.34的主机地址全部设置为1就是192.12.34.255。</p>
</blockquote>
<ol start="2">
<li>本地广播</li>
</ol>
<blockquote>
<p>本地广播:本地广播中使用的IP地址限定为255.255.255.255。例如，192.32.24网络中的主机向255.255.255.255传输数据 时，数据将传递到192.32.24网络中的所有主机。</p>
</blockquote>
<blockquote>
<p>两种广播区别方式主要看IP地址</p>
</blockquote>
<h1>9.标准I/O函数</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/home/wj/.config/Typora/typora-user-images/image-20230707102228664.png" alt="image-20230707102228664"></p>
<blockquote>
<p>使用标准I/O函数会得到额外的缓冲支持，创建套接字时操作系统会准备I/O缓冲。</p>
</blockquote>
<blockquote>
<p>设置缓冲的主要目的是为了提高性能，但套接字中的缓冲主要是为了实现TCP协议而设立的。与之相反，使用标准I/O函数的主要目的是为了提高性能。</p>
</blockquote>
<h2 id="9-1fdopen函数">9.1fdopen函数</h2>
<p>fdopen 是 C 语言中的一个库函数，用于将已有的文件描述符（文件句柄）关联到一个 FILE 类型的流。</p>
<p>它的原型为：FILE *fdopen(int fd, const char *mode);</p>
<p>参数 fd 是一个已存在的文件描述符，mode 是以字符串形式表示的文件访问模式。fdopen 函数将文件描述符 fd 关联到一个 FILE 类型的流，并返回此流的指针。</p>
<h2 id="9-2-fileno函数">9.2 fileno函数</h2>
<p>fileno 是 C 语言中的一个库函数，用于获取一个 FILE 类型流对应的文件描述符（文件句柄）。</p>
<p>它的原型为：int fileno(FILE *stream);</p>
<p>参数 stream 是一个指向 FILE 类型结构体的指针，fileno 函数返回与该流相关联的文件描述符。</p>
<h1>10分离I/O流</h1>
<blockquote>
<p>调用fopen函数打开文件后可以与文件交换数据，因此说明用fopen函数后创建了“流”(stream)。此处的“流”是指“数据流动”，但通常可以比喻为“以数据收发为目的的一种桥梁”。可以将“流”理解为<strong>数据收发路径</strong></p>
<p>流分离的好处：</p>
<ol>
<li>为了将FILE指针按读模式和写模式加以区分</li>
<li>可以通过区分 读写模式降低实现难度</li>
<li>通过区分I/O缓冲提高缓冲性能</li>
</ol>
</blockquote>
<h2 id="10-1-文件描述符的复制和半关闭">10.1 文件描述符的复制和半关闭</h2>
<blockquote>
<p><strong>销毁所有文件描述符后才能销毁套接字</strong></p>
</blockquote>
<blockquote>
<p>为了访问同一件文件或套接字，创建另一个文件描述符</p>
<p>​	通常的“复制”很容易让人理解为将包括文件描述符整数值在内的所有内容进行复制，而此处的“复制”方式却不同。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">dup</span><span class="params">(<span class="type">int</span> fildes)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">dup2</span><span class="params">(<span class="type">int</span> fildes,<span class="type">int</span> fildes2)</span>;</span><br><span class="line">	*fildes	需要复制的文件描述符</span><br><span class="line">    *fildes2 明确指定的文件描述符整数值</span><br></pre></td></tr></table></figure>
<blockquote>
<p>无论复制出多少文件描述符，均应调用shutdown函数发送EOF并进入半关闭状态。</p>
</blockquote>
<h1>11.优于select的epoll</h1>
<blockquote>
<p>epoll_create:创建保存文件描述符的空间</p>
<p>epoll_ctl:向空间注册并注销文件描述符</p>
<p>epoll_wait:与select函数类似，等待文件描述符发生变化。</p>
<p>​	epoll方式下由操作系统负责保存监视对象文件描述符，因此需要向操作系统请求创建保存文件描述符的空间，此时使用的函数就是epoll_create.</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/home/wj/.config/Typora/typora-user-images/image-20230709154802032.png" alt="image-20230709154802032"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="type">__uint32_t</span> events;  <span class="comment">// 表示事件类型的位掩码</span></span><br><span class="line">    <span class="type">epoll_data_t</span> data;  <span class="comment">// 用户数据</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span> <span class="title">epoll_data</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *ptr;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">__uint32_t</span> u32;</span><br><span class="line">    <span class="type">__uint64_t</span> u64;</span><br><span class="line">&#125; <span class="type">epoll_data_t</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>events</code>字段是一个位掩码，表示事件类型，可以是以下几种（可以通过OR运算符组合使用）：</p>
<ul>
<li><code>EPOLLIN</code>：需要读取数据的情况</li>
<li><code>EPOLLOUT</code>：输出缓冲为空，可以立即发送数据的情况。</li>
<li>EPOLLPRI: 收到OOB数据的情况</li>
<li><code>EPOLLRDHUP</code>：断开连接或半关闭的情况，这在边缘触发方式下非常有用。</li>
<li><code>EPOLLHUP</code>：连接关闭或发生错误。</li>
<li><code>EPOLLERR</code>：发生错误的情况。</li>
<li><code>EPOLLET</code>：以边缘触发的方式得到事件通知。</li>
<li><code>EPOLLONESHOT</code>：发生一次事件后，相应文件描述符不再收到事件通知。因此需要向EPOLL_CTL函数的第二个参数传递EPOLL_CTL_MOD,再次设置事件。</li>
</ul>
</blockquote>
<blockquote>
<p>epoll方式中通过如上结构体epoll_event将发生变化的（发生事件的）文件描述符单独集中到一起。</p>
</blockquote>
<h2 id="11-1epoll-create函数">11.1epoll_create函数</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">epoll_create</span><span class="params">(<span class="type">int</span> size)</span>;</span><br><span class="line">	*size epoll实例的大小</span><br><span class="line">        </span><br><span class="line">调用epoll_create函数时创建的文件描述符保存空间称为“epoll例程”，size值是不决定epoll例程的大小，而仅供操作系统参考。</span><br></pre></td></tr></table></figure>
<h2 id="11-2epoll-ctl函数">11.2epoll_ctl函数</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">epoll_ctl</span><span class="params">(<span class="type">int</span> epfd, <span class="type">int</span> op, <span class="type">int</span> fd, <span class="keyword">struct</span> epoll_event *event)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数解释如下：</p>
<ul>
<li>
<p><code>epfd</code>：epoll实例的文件描述符，通过调用<code>epoll_create</code>函数获取。</p>
</li>
<li>
<pre><code class="language-c"></code></pre>
</li>
</ul>
<p>op</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>：控制操作的类型，可以是以下几种取值：</p>
<ul>
<li>
<p><code>EPOLL_CTL_ADD</code>：添加一个文件描述符到epoll实例中。</p>
</li>
<li>
<p><code>EPOLL_CTL_MOD</code>：修改epoll实例中的一个文件描述符的事件设置。</p>
</li>
<li>
<p><code>EPOLL_CTL_DEL</code>：从epoll实例中删除一个文件描述符。</p>
</li>
<li>
<p><code>fd</code>：需要添加、修改或删除的文件描述符。</p>
</li>
<li>
<p><code>event</code>：指向<code>epoll_event</code>结构体的指针，用于设置文件描述符上的事件和其他选项。</p>
</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&gt;`epoll_ctl`函数用于将文件描述符添加、修改或删除到epoll实例中，以及设置相应的事件。它可以让应用程序监控多个文件描述符的事件，实现高效的I/O复用。</span><br><span class="line"></span><br><span class="line">&gt;1. **epoll_event结构体用于保存发生事件的文件描述符集合**</span><br><span class="line">&gt;2. **epoll_event结构体用于用于注册关注的事件。**</span><br><span class="line"></span><br><span class="line">## 11.3 epoll_wait函数</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">int epoll_wait(int epfd, struct epoll_event *events, int maxevents, int timeout);</span><br></pre></td></tr></table></figure>
</blockquote>
<p><strong>调用函数后，返回发生事件的文件描述符数，同时在第二个参数指向的缓冲中保存发生事件的文件描述符集合。</strong></p>
<p>参数解释如下：</p>
<ul>
<li>
<p><code>epfd</code>：epoll实例的文件描述符，通过调用<code>epoll_create</code>或<code>epoll_create1</code>函数创建。</p>
</li>
<li>
<p><code>events</code>：保存发生事件的文件描述符集合的结构体地址值</p>
</li>
<li>
<p><code>maxevents</code>：<code>events</code>数组的大小，表示最多能够接受的事件数量。</p>
</li>
<li>
<pre><code>timeout
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  ：等待事件的超时时间，单位为毫秒，可以有以下取值：</span><br><span class="line"></span><br><span class="line">    - `-1`：无限等待，直到有事件就绪。</span><br><span class="line">    - `0`：立即返回，无论是否有事件就绪。</span><br><span class="line">    - 正整数：等待指定时间内是否有事件就绪。</span><br><span class="line"></span><br><span class="line">函数返回值表示`events`数组中实际就绪的事件数量，如果返回值为`-1`表示发生错误。</span><br><span class="line"></span><br><span class="line">## 11.4 条件触发和边缘触发</span><br><span class="line"></span><br><span class="line">1. 条件触发方式中，只要输入缓冲有数据就会一直通知该事件。(epoll_wait通知事件发生)</span><br><span class="line">2. 边缘触发中输入缓冲收到数据仅通知1次该事件。</span><br><span class="line"></span><br><span class="line"># 12.多线程</span><br><span class="line"></span><br><span class="line">1. 进程：在操作系统构成单独执行流的单位。</span><br><span class="line">2. 线程：在进程构成单独执行流的单位。</span><br><span class="line"></span><br><span class="line">![image-20230710152143407](/home/wj/.config/Typora/typora-user-images/image-20230710152143407.png)</span><br><span class="line"></span><br><span class="line">## 12.1`pthread_create`函数</span><br><span class="line"></span><br><span class="line">```c</span><br><span class="line">#include &lt;pthread.h&gt;</span><br><span class="line"></span><br><span class="line">int pthread_create(pthread_t *thread, const pthread_attr_t *attr,void *(*start_routine) (void *), void *arg);</span><br></pre></td></tr></table></figure>

</code></pre>
</li>
</ul>
<p><code>pthread_create</code>函数接受四个参数：</p>
<ul>
<li><code>thread</code>：一个指向<code>pthread_t</code>类型的指针，用于存储新创建线程的标识符(线程id)。</li>
<li><code>attr</code>：一个指向<code>pthread_attr_t</code>类型的指针，用于设置线程的属性，通常可以使用<code>NULL</code>来使用默认属性。</li>
<li><code>start_routine</code>：一个指向线程的主函数的指针，该函数将在新创建的线程中被调用。</li>
<li><code>arg</code>：传递给线程主函数的参数。</li>
</ul>
<h2 id="12-2pthread-join函数">12.2pthread_join函数</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">pthread_join</span><span class="params">(<span class="type">pthread_t</span> thread, <span class="type">void</span> **retval)</span>;</span><br></pre></td></tr></table></figure>
<p>参数说明：</p>
<ul>
<li><code>thread</code>：要等待结束的线程的标识符；</li>
<li><code>retval</code>：一个指向指针的指针，用于存储线程的返回值。</li>
</ul>
<p>函数返回值：</p>
<ul>
<li>如果线程成功结束，则返回0；</li>
<li>如果在调用<code>pthread_join</code>时出现错误，则返回相应的错误代码。</li>
</ul>
<h2 id="12-3-临界区">12.3 临界区</h2>
<blockquote>
<p>函数内同时运行多个线程时引起问题的多条语句构成的代码块。</p>
<p>两条不同语句由不同线程同时执行时，也可能构成临界区，前提是这两条语句访问同一内存空间。</p>
</blockquote>
<h3 id="12-3-1互斥量">12.3.1互斥量</h3>
<p>互斥量就是一种优秀的锁，以下是互斥量的创建和销毁函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_init</span><span class="params">(<span class="type">pthread_mutex_t</span> * mutex,<span class="type">const</span> <span class="type">pthread_mutexattr_t</span> * attr)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_destroy</span><span class="params">(<span class="type">pthread_mutex_t</span> * mutex)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>成功时返回0,失败时返回其他值。</p>
<p>mutex 创建互斥量时传递保存互斥量的变量地址值，销毁时传递需要销毁的互斥量地址值</p>
<p>attr 传递即将创建的互斥量属性，没有特别需要指定的属性时传递NULL</p>
</blockquote>
<p>以下是利用互斥量锁住或释放临界区时使用的函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_lock</span><span class="params">(<span class="type">pthread_mutex_t</span> * mutex)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_mutex_unlock</span><span class="params">(<span class="type">pthread_mutex_t</span> * mutex)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>成功时返回0,失败时返回其他值。</p>
</blockquote>
<h3 id="12-3-2信号量">12.3.2信号量</h3>
<p>以下是信号量创建及销毁方法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_init</span><span class="params">(<span class="type">sem_t</span> * sem,<span class="type">int</span> pshared,<span class="type">unsigned</span> <span class="type">int</span> value)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_destory</span><span class="params">(<span class="type">sem_t</span> * sem)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>sem</strong>	创建信号量时传递保存信号量的变量地址值，销毁时传递需要销毁的信号量变量地址值</p>
<p><strong>pshared</strong> 传递其他值时，创建可有多个进程共享的信号量；传递0时，创建只允许1个进程内部使用的信号量。我们需要完成同一进程内的线程同步，故传递0。</p>
<p><strong>value</strong> 指定新创建的信号量初值。</p>
</blockquote>
<p>以下函数相当于互斥量lock,unlock函数</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_post</span><span class="params">(<span class="type">sem_t</span> * sem)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">sem_wait</span><span class="params">(<span class="type">sem_t</span> * sem)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>成功时返回0,失败时返回其他值。</p>
<p>sem 传递保存信号量读取值的变量地址值，传递sem_post时信号量增1，传递给sem_wait时信号量减1。</p>
</blockquote>
<h2 id="12-4线程的销毁">12.4线程的销毁</h2>
<ol>
<li>
<p>调用pthread_join函数</p>
<p>等待线程执行完以后才销毁</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pthread_detach</span><span class="params">(<span class="type">pthread_t</span> thread)</span>;</span><br></pre></td></tr></table></figure>
<p>成功时返回0,失败时返回其他值。</p>
</li>
<li>
<p>调用pthread_detach函数</p>
</li>
</ol>
<h1>13.线程共享区域</h1>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:%5CUsers%5C%E7%8E%8B%E5%BB%BA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230804150812323.png" alt="image-20230804150812323"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:%5CUsers%5C%E7%8E%8B%E5%BB%BA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230804150840232.png" alt="image-20230804150840232"></p>
<h1>13.Windows平台下线程的使用</h1>
<p>​	内核对象：操作系统为了记录资源相关信息的而在其内部生成的数据块。</p>
<p>​	内核对象所有者是内核(操作系统)，即内核对象的创建，管理，销毁时机的决定等工作由操作系统完成。</p>
<p><code>HANDLE CreateThread(...)</code> 是Windows API中用于创建线程的函数之一。它返回一个线程句柄（HANDLE），以便后续对线程进行操作。</p>
<h2 id="13-1-CreateThread函数">13.1 CreateThread函数</h2>
<p>函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HANDLE <span class="title function_">CreateThread</span><span class="params">(</span></span><br><span class="line"><span class="params">  LPSECURITY_ATTRIBUTES   lpThreadAttributes,</span></span><br><span class="line"><span class="params">  SIZE_T                  dwStackSize,</span></span><br><span class="line"><span class="params">  LPTHREAD_START_ROUTINE  lpStartAddress,</span></span><br><span class="line"><span class="params">  LPVOID                  lpParameter,</span></span><br><span class="line"><span class="params">  DWORD                   dwCreationFlags,</span></span><br><span class="line"><span class="params">  LPDWORD                 lpThreadId</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<p>参数说明如下：</p>
<ul>
<li><code>lpThreadAttributes</code>：指向SECURITY_ATTRIBUTES结构体的指针，用于指定线程的安全属性（例如继承性等）。默认为NULL，表示使用默认安全属性。</li>
<li><code>dwStackSize</code>：指定线程堆栈的初始大小（以字节为单位）。0表示使用默认大小。</li>
<li><code>lpStartAddress</code>：线程函数的指针，指定线程的入口地址。线程函数的返回类型为DWORD并带有一个LPVOID参数（即<code>DWORD WINAPI ThreadFunction(LPVOID lpParam)</code>）。</li>
<li><code>lpParameter</code>：传递给线程函数的参数，可以为NULL。</li>
<li><code>dwCreationFlags</code>：指定创建线程的标志。常用的有0（立即启动线程）和CREATE_SUSPENDED（创建线程但暂时不启动）。</li>
<li><code>lpThreadId</code>：指向DWORD类型的变量的指针，用于存储新线程的标识符。可以为NULL，表示不获取新线程的标识符。</li>
</ul>
<blockquote>
<p>windows线程在首次调用main函数返回时销毁(销毁时间点和销毁方法与Linux不同)。还有其他方法可以终止线程，但最好的方法就是让main函数终止(返回)。</p>
</blockquote>
<h2 id="13-2-beginthreadex函数">13.2 <code>_beginthreadex</code>函数</h2>
<p><code>_beginthreadex</code>函数是一个在Windows操作系统上用于创建线程的函数。它位于Windows API中的<code>process.h</code>头文件中。</p>
<p>该函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> _beginthreadex(</span><br><span class="line">    <span class="type">void</span>* security, </span><br><span class="line">    <span class="type">unsigned</span> stack_size, </span><br><span class="line">    <span class="type">unsigned</span> (* start_address)(<span class="type">void</span>*), 	     </span><br><span class="line">    <span class="type">void</span>* arglist, </span><br><span class="line">    <span class="type">unsigned</span> initflag, </span><br><span class="line">    <span class="type">unsigned</span>* thrdaddr</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>参数解析：</p>
<ul>
<li><code>security</code>（可选）：指定线程安全相关的参数，一般传入<code>NULL</code>。</li>
<li><code>stack_size</code>（可选）：指定线程堆栈的大小，一般传入0表示使用默认值。</li>
<li><code>start_address</code>：指定线程的入口函数，也就是线程开始执行的地方。该函数必须以无返回值、一个<code>void*</code>参数类型定义，也可以使用<code>__stdcall</code>修饰。</li>
<li><code>arglist</code>：传递给线程入口函数的参数。</li>
<li><code>initflag</code>：指定线程的初始标识，一般传入0表示创建成功。</li>
<li><code>thrdaddr</code>（可选）：指向一个<code>unsigned</code>变量的指针，用于保存新线程的ID。</li>
</ul>
<blockquote>
<p><strong>句柄指向内核对象</strong>，通过内核对象可以区分线程，也就是说线程句柄成为区分线程的工具。</p>
<p>“句柄的整数值在不同进程中可能出现重复，但线程ID在跨进程范围内不会出现重复”</p>
</blockquote>
<h2 id="13-3验证内核对象signaled状态函数">13.3验证内核对象signaled状态函数</h2>
<blockquote>
<p>signaled:线程结束运行</p>
<p>non-signaled:线程正在运行</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">DWORD <span class="title function_">WaitForSingleObject</span><span class="params">(</span></span><br><span class="line"><span class="params">  HANDLE hHandle,     <span class="comment">// 要等待的对象句柄</span></span></span><br><span class="line"><span class="params">  DWORD dwMilliseconds  <span class="comment">// 等待时间，以毫秒为单位,当等待时间为INFINITE时，函数会一直等待直到对象的状态发生变化</span></span></span><br><span class="line"><span class="params">)</span>;</span><br><span class="line"><span class="comment">//返回值：进入signaled状态返回WAIT_OBJECT_0,超时返回WAIT_TIMEOUT</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">DWORD <span class="title function_">WaitForMultipleObjects</span><span class="params">(</span></span><br><span class="line"><span class="params">  DWORD        nCount,         <span class="comment">// 等待的对象数目</span></span></span><br><span class="line"><span class="params">  <span class="type">const</span> HANDLE *lpHandles,     <span class="comment">// 对象句柄数组</span></span></span><br><span class="line"><span class="params">  BOOL         bWaitAll,       <span class="comment">// 如果为TRUE,则所有内核对象全部变为signaled时返回，如果为FALSE,则是要有内核对象的状态变为signaled就返回</span></span></span><br><span class="line"><span class="params">  DWORD        dwMilliseconds <span class="comment">// 等待时间，以毫秒为单位,当等待时间为INFINITE时，函数会一直等待直到对象的状态发生变化</span></span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<h1>14.Windows中的线程同步</h1>
<p>用户模式：应用程序的运行模式</p>
<p>内核模式：操作系统的运行模式</p>
<blockquote>
<p>用户模式同步:用户模式同步是用户模式下进行的同步,即无需操作系统的帮助而在应用程序级别进行的同步</p>
<p>​	1.速度快</p>
<p>​	2.功能上存在一定局限性</p>
<p>内核模式同步：</p>
<p>​	1.比用户模式同步提供的功能更多</p>
<p>​	2.可以指定超市，防止产生死锁</p>
</blockquote>
<blockquote>
<p><strong>因为线程同步是基于内核对象的操作，所以可以进行不同进程之间的同步。因为内核对象并不属于某一进程，而是操作系统拥有并管理的。</strong></p>
</blockquote>
<h2 id="14-1基于CRITICAL-SECTION的同步">14.1基于CRITICAL_SECTION的同步</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows. h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">InitializeCriticalSection</span><span class="params">(LPCRITICAL_ SECTION <span class="number">1</span>pCriticalSection)</span>;<span class="comment">//初始化资源</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DeleteCriticalSection</span><span class="params">(LPCRITICAL_ SECTION <span class="number">1</span>pCriticalSection)</span>;<span class="comment">//释放资源</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>lpCriticalSection Init…函数中传入需要初始化的CRITICAL_ <em>SECTION对象的地址值，反之，Del…函<br>
数中传入需要解除的CRITICAL</em> _SECTION对象的地址值。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows. h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">EnterCriticalSection</span><span class="params">(LPCRITICAL_ SECTION <span class="number">1</span>pCriticalSection)</span>;<span class="comment">//上锁</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">LeaveCriticalSection</span><span class="params">(LPCRITICAL_ SECTION lpCriticalSection)</span>;<span class="comment">//释放锁</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>IpCriticalSection 获取(拥有)和释放的CRITICAL__SECTION对象的地址值。</p>
</blockquote>
<h2 id="14-2基于互斥量-Mutual-Exclusion-对象的同步">14.2基于互斥量(Mutual Exclusion)对象的同步</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">HANDLE <span class="title function_">CreateMutex</span><span class="params">(LPSECURITY ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCTSTR <span class="number">1</span>pName)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>成功时返回创建的互斥量对象句柄，失败时返回NULL。<br>
IpMutexAttributes: 传递安全相关的配置信息，使用默认安全设置时可以传递NULL。<br>
bInitialOwner:如果为TRUE，则创建出的互斥量对象属于调用该函数的线程，同时进入。<br>
non-signaled:状态;如果为FALSE，则创建出的互斥量对象不属于任何线程，此时状态为signaled。<br>
IpName:用于命名互斥量对象。传入NULL时创建无名的互斥量对象。</p>
</blockquote>
<p><strong>互斥量属于内核对象，以下是互斥量的销毁</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">BOOL <span class="title function_">CloseHandle</span><span class="params">(HANDLE hObject)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>成功时返回TRUE，失败时返回FALSE。<br>
hObject:要销毁的内核对象的句柄。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows. h&gt;</span></span></span><br><span class="line">BOOL <span class="title function_">ReleaseMutex</span><span class="params">(HANDLE hMutex)</span> ;<span class="comment">//释放互斥量，WaitForSingleObject获取互斥量。</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>成功时返回TRUE，失败时返回FALSE。</p>
<ul>
<li>hMutex 需要释放(解除拥有)的互斥量对象句柄。</li>
</ul>
</blockquote>
<blockquote>
<p>接下来分析获取和释放互斥量的过程。<strong>互斥量被某一线程获取时(拥有时)为non- signaled状态，释放时(未拥有时)进人signaled状态</strong>。因此，可以使用WaitForSingleObject函数验证互斥量是否已分配。该函数的调用结果有如下2种:</p>
<ol>
<li>调用后进人阻塞状态:互斥量对象已被其他线程获取，现处于non- signaled状态。</li>
<li>调用后直接返回:其他线程未占用互斥量对象，现处于signaled状态。互斥量在WaitForSingleObject函数返回后自动进入non- signaled状态。</li>
</ol>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:%5CUsers%5C%E7%8E%8B%E5%BB%BA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230721134434978.png" alt="image-20230721134434978"></p>
<h2 id="14-3基于信号量对象的同步">14.3基于信号量对象的同步</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows. h&gt;</span></span></span><br><span class="line">HANDLE <span class="title function_">CreateSemaphore</span><span class="params">(</span></span><br><span class="line"><span class="params">LPSECURITY ATTRIBUTES <span class="number">1</span>pSemaphoreAttributes, LONGlInitialCount,</span></span><br><span class="line"><span class="params">LONG lMaximumCount, LPCTSTR <span class="number">1</span>pName)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>成功时返回创建的信号量对象的句柄，失败时返回NULL。<br>
IpSemaphoreAttributes:安全配置信息，采用默认安全设置时传递NULL。<br>
IInitialCount:指定信号量的初始值，应大于等于0小于等于IMaximumCount。<br>
IMaximumCount:信号量的最大值。该值为1时，信号量变为只能表示0和1的二进制信号量。<br>
lpName:用于命名信号量对象。传递NULL时创建无名的信号量对象。</p>
<p><strong>可以利用信号量为0时进入non-signaled状态，大于0时进入signaled状态的特性进行同步，向IInitialCount参数传递0时，创建non-signaled状态的信号量对象，而向IMaximumCount传入3时，信号量最大值为3，因此可以实现3个线程同时访问临界区的同步。</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows. h&gt;</span></span></span><br><span class="line">BOOL <span class="title function_">ReleaseSemaphore</span> <span class="params">(HANDLE hSemaphore, LONG lReleaseCount, LPLONG1pPreviousCount)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>成功时返回TRUE，失败时返回FALSE。</p>
<ol>
<li>hSemaphore: 传递需要释放的信号量对象。</li>
<li>lReleaseCount: 释放意味着信号量值的增加，通过该参数可以指定增加的值。超过最大值则不增加，返回FALSE。</li>
<li>lpPreviousCount: 用于保存修改之前值的变量地址，不需要时可传递NULL。</li>
</ol>
</blockquote>
<blockquote>
<p>信号量对象的值大于0时成为signaled状态，为0时成为non-signaled状态。因此，调用WaitForSingleObject函数时，信号量大于0的情况下才会返回。返回的同时将信号量值减1，同时进入non-signaled状态(当然，仅限于信号量减1后等于0的情况)。可以通过如下程序结构保护临界区。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:%5CUsers%5C%E7%8E%8B%E5%BB%BA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230721134448299.png" alt="image-20230721134448299"></p>
<h2 id="14-4基于事件对象的同步">14.4基于事件对象的同步</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">HANDLE <span class="title function_">CreateEvent</span><span class="params">(LPSECURITY_ ATTRIBUTES <span class="number">1</span>pEventAttributes, BOOL bManualReset,BOOL bInitialState, LPCTSTR lpName)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>成功时返回创建的事件对象句柄，失败时返回NULL。<br>
●IpEventAttributes 安全配置相关参数，采用默认安全配置时传入NULL。<br>
●bManualReset 传入TRUE时创建manual- reset模式的事件对象，传入FALSE时创建auto-reset模式的事件对象。<br>
●bInitialState 传入TRUE时创建signaled状态的事件对象，传入FALSE时创建non- signaled状态的事件对象。<br>
●IpName 用于命名事件对象。传递NULL时创建无名的事件对象。</p>
<p>传入TRUE时创建manual-reset模式的事件对象，此时即使WaitForSingleObject函数返回后也不会回到non-signaled状态。需要手动更改状态，以下是更改状态的函数。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">BOOL <span class="title function_">ResetEvent</span> <span class="params">(HANDLE hEvent)</span>; <span class="comment">//to the non-signaled</span></span><br><span class="line">BOOL <span class="title function_">SetEvent</span> <span class="params">(HANDLE hEvent)</span>;<span class="comment">//to the signaled</span></span><br><span class="line">成功时返回TRUE，失败时返回FALSE。</span><br></pre></td></tr></table></figure>
<h2 id="14-4内核对象的销毁">14.4内核对象的销毁</h2>
<p><strong>互斥量属于内核对象，以下是互斥量的销毁</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;windows.h&gt;</span></span></span><br><span class="line">BOOL <span class="title function_">CloseHandle</span><span class="params">(HANDLE hObject)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>成功时返回TRUE，失败时返回FALSE。<br>
hObject:要销毁的内核对象的句柄。</p>
<p>​	事件对象，信号量，互斥量都属于内核对象</p>
<p>​	<strong>句柄指向内核对象</strong></p>
</blockquote>
<h1>15.异步通知I/0模型</h1>
<blockquote>
<p>异步I/O是指I/O函数的返回时刻与数据收发的完成时刻不一致。</p>
<p>同步I/O是指I/O函数的返回时刻与数据收发的完成时刻一致</p>
<p>​	与“select函数只在需要或可以进行I/O的情况下返回”不同，异步通知模型中函数的返回值与I/O状态无关</p>
</blockquote>
<h2 id="15-1-WSAEventSelect函数">15.1 WSAEventSelect函数</h2>
<blockquote>
<p><strong>该函数用于指定某一段套接字为事件监视对象</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;winsock2. h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">WSAEventSelect</span><span class="params">(SOCKET s, WSAEVENT hEventobject, <span class="type">long</span> lNetworkEvents)</span>;</span><br></pre></td></tr></table></figure>
<p>​	成功时返回0，失败时返回SOCKET_ _ERROR。</p>
<ol>
<li>
<p>s 监视对象的套接字句柄。</p>
</li>
<li>
<p>hEventObject 传递事件对象句柄以验证事件发生与否。</p>
</li>
<li>
<p>INetwork Events 希望监视的事件类型信息。</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:%5CUsers%5C%E7%8E%8B%E5%BB%BA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230724160716445.png" alt="image-20230724160716445"></p>
</li>
</ol>
<h2 id="15-2-manual-reset模式事件对象的其他创建方法以及销毁">15.2 manual_reset模式事件对象的其他创建方法以及销毁</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:%5CUsers%5C%E7%8E%8B%E5%BB%BA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230724161249412.png" alt="image-20230724161249412"></p>
<h2 id="15-3验证是否发生事件">15.3验证是否发生事件</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:%5CUsers%5C%E7%8E%8B%E5%BB%BA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230724161435628.png" alt="image-20230724161435628"></p>
<h2 id="15-4-区分事件类型">15.4 区分事件类型</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:%5CUsers%5C%E7%8E%8B%E5%BB%BA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230724162200372.png" alt="image-20230724162200372"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:%5CUsers%5C%E7%8E%8B%E5%BB%BA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230724163553519.png" alt="image-20230724163553519"></p>
<h1>16.重叠I/O模型</h1>
<blockquote>
<p>重叠I/O是一种异步通信的方式，用于在输入和输出操作之间实现并发性。它允许<strong>同时处理多个输入和输出请求，而无需等待每个请求完成</strong>。</p>
<p>在传统的阻塞I/O模型中，当一个输入或输出操作被触发时，程序会等待操作完成，然后再进行下一个操作。这种方式在多任务环境下效率较低，因为等待一个操作完成会导致系统无法同时处理其他请求。</p>
<p>而重叠I/O则通过使用非阻塞I/O操作和事件驱动机制来提高效率。<strong>当一个输入或输出操作被触发时，程序会立即返回，并允许执行其他操作。当操作完成时，系统会通知程序，并进行相应的处理。这样，程序可以不断地发起新的操作，而无需等待之前的操作完成</strong>。</p>
<p>重叠I/O可以在许多情况下提高系统性能，特别是在需要同时处理大量输入和输出请求的情况下，例如网络服务器、数据库系统等。它可以显著减少处理时间，提高系统的吞吐量和响应性能。</p>
</blockquote>
<h2 id="16-1创建重叠I-O套接字">16.1创建重叠I/O套接字</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:%5CUsers%5C%E7%8E%8B%E5%BB%BA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230724172304872.png" alt="image-20230724172304872"></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:%5CUsers%5C%E7%8E%8B%E5%BB%BA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230724172522605.png" alt="image-20230724172522605"></p>
<h2 id="16-2WSASend函数·">16.2WSASend函数·</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:%5CUsers%5C%E7%8E%8B%E5%BB%BA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230726083846089.png" alt="image-20230726083846089"></p>
<blockquote>
<p>​	如果向lpOverlapped传递NULL,WSASend函数的第一个参数中的句柄所指的套接字将一阻塞模式工作。</p>
<p>​	利用WSASend函数同时向多个目标传输数据时，需要分别构建传入第六个参数WSAOVERLAPPED结构体变量。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:%5CUsers%5C%E7%8E%8B%E5%BB%BA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230726105639777.png" alt="image-20230726105639777"></p>
<h2 id="16-3WSAGetOverlappedResult函数">16.3WSAGetOverlappedResult函数</h2>
<blockquote>
<p>WSASend函数调用过程中，函数返回时间点和数据传输完成时间点并非总不一致，如果输出缓冲是空的，且传输的数据并不大，那么函数调用后可以立即完成数据传输。这时候可以通过函数和lpNumberOfBytesSent获取实际传输的数据大小。</p>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:%5CUsers%5C%E7%8E%8B%E5%BB%BA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230726090624389.png" alt="image-20230726090624389"></p>
<h2 id="16-4WSARecv函数">16.4WSARecv函数</h2>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:%5CUsers%5C%E7%8E%8B%E5%BB%BA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230726090709300.png" alt="image-20230726090709300"></p>
<h2 id="16-5-重叠I-O的I-O完成确认">16.5 重叠I/O的I/O完成确认</h2>
<blockquote>
<ol>
<li>
<p>利用WSASend,WSARecv函数的第六个参数，基于事件对象。</p>
</li>
<li>
<p>利用WSASend,WSARecv函数的第七个参数，基于Completion Routine。</p>
</li>
</ol>
</blockquote>
<h3 id="16-5-1-使用事件对象">16.5.1 使用事件对象</h3>
<blockquote>
<ol>
<li>完成I/O时，WSAOVERLAPPED结构体变量引用的事件对象将变为signaled状态(<strong>事件对象WSAEVENT</strong>)。</li>
<li>为了验证I/O的完成和完成结果，需要调用WSAGetOverlappedResult函数</li>
</ol>
</blockquote>
<h3 id="16-5-2-使用Completion-Routine函数">16.5.2 使用Completion Routine函数</h3>
<blockquote>
<p>WSASend,WSASRecv函数的最后一个参数中指定的Completion Routine(以下简称CR)函数验证I/O完成情况。注册CR的具有如下含义：</p>
<p>​			“Pending的I/O完成时调用此函数”</p>
<p>如果执行重要任务时突然调用Completion Routine，则有可能破坏程序的正常执行流。因此操作系统通常会预先定义规则：</p>
<p>​			“只有请求I/O的线程处于alertable wait状态时才能调用Completion Routine函数”</p>
<p>“alertable wait状态”是等待接收操作系统消息的线程状态。调用下列函数时进入alertable wait状态。</p>
<ol>
<li>WaitForSingleObjectEx</li>
<li>WaitForMultipleObjectsEx</li>
<li>WSAWaitForMultipleEvents</li>
<li>SleepEx</li>
</ol>
</blockquote>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="C:%5CUsers%5C%E7%8E%8B%E5%BB%BA%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20230726150903116.png" alt="image-20230726150903116"></p>
<h1>17.IOCP</h1>
<p>​	让main线程(在main函数内部)调用accept函数，再单独创建1个线程负责客户端I/O。这就是IOCP中采用的服务器端模型。换言之，IOCP将创建专用的I/O线程，该线程负责与所有客户端进行I/O。</p>
<h2 id="17-1创建完成端口对象">17.1创建完成端口对象</h2>
<p>IOCP中<strong>已完成的I/O信息将注册到完成端口对象</strong>(Completion Port,简称CP对象)，但这个过程并非单纯的注册，首先需要经过如下请求过程:</p>
<p>​		该套接字的I/O完成时，请把状态信息注册到指定CP对象。</p>
<p>该过程称为“套接字和CP对象之间的连接请求”。因此,为了实现基于IOCP模型的服务器端，需要做如下2项工作。</p>
<ol>
<li>创建完成端口对象。</li>
<li>建立完成端口对象和套接字之间的联系。</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HANDLE <span class="title function_">CreateIoCompletionPort</span><span class="params">(</span></span><br><span class="line"><span class="params">  HANDLE    FileHandle,</span></span><br><span class="line"><span class="params">  HANDLE    ExistingCompletionPort,</span></span><br><span class="line"><span class="params">  ULONG_PTR CompletionKey,</span></span><br><span class="line"><span class="params">  DWORD     NumberOfConcurrentThreads</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<ul>
<li><code>FileHandle</code>：要连接到CP对象的套接字句柄。(创建CP对象时传递INVALID_HANDLE_VALUE)</li>
<li><code>ExistingCompletionPort</code>：要链接套接字的CP对象句柄。(创建CP对象时传递NULL)</li>
<li><code>CompletionKey</code>：传递已完成I/O相关信息，关于该参数将在稍后介绍的GetQueued-CompletionStatus函数中共同讨论。(创建CP对象时传递0)</li>
<li><code>NumberOfConcurrentThreads</code>：无论传递何值，只要该函数的第二个参数非NULL就会忽略。</li>
</ul>
</blockquote>
<p><strong>只要FileHandle的I/O完成时，相关信息就会注册到ExistingCompletionPort指向的CP对象中。</strong></p>
<h2 id="17-2确认完成端口对象已完成的I-O和线程的I-O处理">17.2确认完成端口对象已完成的I/O和线程的I/O处理</h2>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">BOOL <span class="title function_">GetQueuedCompletionStatus</span><span class="params">(</span></span><br><span class="line"><span class="params">  HANDLE       CompletionPort,</span></span><br><span class="line"><span class="params">  LPDWORD      lpNumberOfBytes,</span></span><br><span class="line"><span class="params">  PULONG_PTR   lpCompletionKey,</span></span><br><span class="line"><span class="params">  LPOVERLAPPED *lpOverlapped,</span></span><br><span class="line"><span class="params">  DWORD        dwMilliseconds</span></span><br><span class="line"><span class="params">)</span>;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>参数说明：</p>
<ul>
<li><code>CompletionPort</code>：要检查的CP对象的句柄。</li>
<li><code>lpNumberOfBytes</code>：用于保存I/O过程中传输的数据大小的变量地址值。</li>
<li><code>lpCompletionKey</code>：用于保存CreateIoCompletionPort函数的第三个参数值的变量地址值。</li>
<li><code>lpOverlapped</code>：用于保存调用WSASend,WSARecv函数时传递OVERLAPPED结构体地址的变量地址值。</li>
<li><code>dwMilliseconds</code>：超时信息，超出该指定时间后将返回FALSE并跳出函数。传递INFINITE时，程序将阻塞，直到已完成I/O信息写入CP对象。</li>
</ul>
</blockquote>
<blockquote>
<p>​	通过GetQueuedCompletionStatus函数的第三个参数得到的是以连接套接字和CP对象为目的而调用的CreateCompletionPort函数的第三个参数值。<br>
​	通过GetQueueCompletionStatus函数的第四个参数得到的是调用WSASend、WSARecv函数时传入的WSAOVERLAPPED结构体变量地址值。</p>
</blockquote>
<blockquote>
<p><strong>IOCP特点：</strong></p>
<ol>
<li>因为是非阻塞模式的I/O，所以不会由I/O引发延迟。</li>
<li>查找已完成I/O时无需添加循环。</li>
<li>无需将作为I/O对象的套接字句柄保存到数组进行管理。</li>
<li>可以调整处理I/O的线程数，所以可在实验数据的基础上选用合适的线程数。</li>
</ol>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/kunagisatomolove">王建</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://kunagisatomolove.github.io/2025/01/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">https://kunagisatomolove.github.io/2025/01/07/计算机网络编程学习笔记/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来源 <a href="https://kunagisatomolove.github.io" target="_blank">王建's 博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/C/">C++</a><a class="post-meta__tags" href="/tags/Windows/">Windows</a><a class="post-meta__tags" href="/tags/TCP-IP/">TCP/IP</a><a class="post-meta__tags" href="/tags/Linux/">Linux</a></div><div class="post-share"><div class="social-share" data-image="/wallpaper/images/6og3lq.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i>赞助</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="/wallpaper/images/wechat.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/wallpaper/images/wechat.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/wallpaper/images/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/wallpaper/images/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div></div><nav class="pagination-post" id="pagination"><a class="pagination-related" href="/2025/01/09/springboot%E8%AE%A4%E8%AF%81%E4%B8%8E%E6%8E%88%E6%9D%83/" title="springboot认证与授权"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/wallpaper/images/8oev1j.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="info"><div class="info-1"><div class="info-item-1">上一篇</div><div class="info-item-2">springboot认证与授权</div></div><div class="info-2"><div class="info-item-1"> 如果不理解oauth协议的推荐阅读 阮一峰的理解OAuth 2.0  当然，我们也要简单介绍下oauth的运行流程： 1234567891011121314151617+--------+                               +---------------+|        |--(A)- Authorization Request -&gt;|   Resource    ||        |                               |     Owner     ||        |&lt;-(B)-- Authorization Grant ---|               ||        |                               +---------------+|        ||        |                               +---------------+|        |--(C)-- Authorization Grant --&gt;|...</div></div></div></a><a class="pagination-related" href="/2025/01/07/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%88%AA%E7%8F%AD%E6%8E%A5%E5%8F%A3%E6%96%87%E6%A1%A3/" title="微服务航班接口文档"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/wallpaper/images/wallhaven-3z61m3_2560x1600.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="info text-right"><div class="info-1"><div class="info-item-1">下一篇</div><div class="info-item-2">微服务航班接口文档</div></div><div class="info-2"><div class="info-item-1">1. 用户微服务接口 1.1. API 接口说明  服务端已开启 CORS 跨域支持 API  认证统一使用 Token 认证 需要授权的 API ，必须在请求头中使用 Authorization 字段提供 token 令牌 使用 HTTP Status Code 标识状态 数据返回格式统一使用 JSON  1.1.1. 支持的请求方法  GET（SELECT）：从服务器取出资源（一项或多项）。 POST（CREATE）：在服务器新建一个资源。 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。 PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。 DELETE（DELETE）：从服务器删除资源。 HEAD：获取资源的元数据。 OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。  1.1.2 返回信息以及状态码说明    状态码 含义 说明     200 OK 请求成功   201 CREATED 创建成功   204 DELETED 删除成功   400 BAD...</div></div></div></a></nav><hr class="custom-hr"/><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i><span> 评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info text-center"><div class="avatar-img"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="https://thirdqq.qlogo.cn/g?b=sdk&amp;nk=2200189658&amp;s=140" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info-name">王建</div><div class="author-info-description">早岁已知世事艰，仍许飞鸿荡云间</div><div class="site-data"><a href="/archives/"><div class="headline">文章</div><div class="length-num">12</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">19</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">5</div></a></div><a id="card-info-btn" target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/kunagisatomolove"><i class="fab fa-github"></i><span>联系我</span></a><div class="card-info-social-icons"><a class="social-icon" href="https://github.com/kunagisatomolove" rel="external nofollow noreferrer" target="_blank" title="Github"><i class="fab fa-github" style="color: #hdhfbb;"></i></a><a class="social-icon" href="mailto:2200189658@qq.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope" style="color: #000000;"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">我是来自南京信息工程大学-计算机科学与技术的后端开发工程师，这是我的第一个博客</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">1.</span> <span class="toc-text">1.TCP套接字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 相关函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-%E5%9F%BA%E4%BA%8EWindos%E7%9A%84%E6%9C%8D%E5%8A%A1%E7%AB%AF"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 基于Windos的服务端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-%E5%9F%BA%E4%BA%8EWindos%E7%9A%84%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 基于Windos的客户端</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-%E5%A5%97%E6%8E%A5%E5%AD%97%E5%87%BD%E6%95%B0%E8%AF%A6%E8%A7%A3"><span class="toc-number">1.4.</span> <span class="toc-text">1.4 套接字函数详解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-socket%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.1.</span> <span class="toc-text">1.4.1 socket函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-bind%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.2.</span> <span class="toc-text">1.4.2 bind函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-3-listen%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.3.</span> <span class="toc-text">1.4.3 listen函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-4-accept%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.4.</span> <span class="toc-text">1.4.4 accept函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-5-connect%E5%87%BD%E6%95%B0"><span class="toc-number">1.4.5.</span> <span class="toc-text">1.4.5 connect函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-6-read%E5%87%BD%E6%95%B0"><span class="toc-number">1.5.</span> <span class="toc-text">1.4.6 read函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-7-write%E5%87%BD%E6%95%B0"><span class="toc-number">1.6.</span> <span class="toc-text">1.4.7 write函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">2.</span> <span class="toc-text">2.UDP套接字</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-%E5%9F%BA%E4%BA%8EUDP%E7%9A%84%E6%95%B0%E6%8D%AEI-O%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 基于UDP的数据I&#x2F;O函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-1-sendto%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.1.</span> <span class="toc-text">2.1.1 sendto函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-2-recvfrom%E5%87%BD%E6%95%B0"><span class="toc-number">2.1.2.</span> <span class="toc-text">2.1.2 recvfrom函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E5%B7%B2%E8%BF%9E%E6%8E%A5%EF%BC%88connected%EF%BC%89UDP%E5%A5%97%E6%8E%A5%E5%AD%97%E4%B8%8E%E6%9C%AA%E8%BF%9E%E6%8E%A5%EF%BC%88unconnected%EF%BC%89UDP%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">2.2.</span> <span class="toc-text">2.2 已连接（connected）UDP套接字与未连接（unconnected）UDP套接字</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">3.</span> <span class="toc-text">3.基于TCP的半关闭</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1%E7%9B%B8%E5%85%B3%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.</span> <span class="toc-text">3.1相关函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-1-shutdown%E5%87%BD%E6%95%B0"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1 shutdown函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">4.</span> <span class="toc-text">4套接字的多种可选项</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1getsockopt%E5%87%BD%E6%95%B0"><span class="toc-number">4.1.</span> <span class="toc-text">4.1getsockopt函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2setsockopt%E5%87%BD%E6%95%B0"><span class="toc-number">4.2.</span> <span class="toc-text">4.2setsockopt函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3Time-wait%E7%8A%B6%E6%80%81"><span class="toc-number">4.3.</span> <span class="toc-text">4.3Time-wait状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-4%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BC%9A%E6%9C%89Time-wait%E7%8A%B6%E6%80%81"><span class="toc-number">4.4.</span> <span class="toc-text">4.4为什么会有Time-wait状态</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-5Nagle%E7%AE%97%E6%B3%95"><span class="toc-number">4.5.</span> <span class="toc-text">4.5Nagle算法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">5.</span> <span class="toc-text">5.多进程服务器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1%E5%AD%90%E8%BF%9B%E7%A8%8B%E7%9A%84%E9%94%80%E6%AF%81"><span class="toc-number">5.1.</span> <span class="toc-text">5.1子进程的销毁</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-1%E5%88%A9%E7%94%A8wait%E5%87%BD%E6%95%B0"><span class="toc-number">5.1.1.</span> <span class="toc-text">5.1.1利用wait函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2%E4%BF%A1%E5%8F%B7%E5%A4%84%E7%90%86"><span class="toc-number">5.2.</span> <span class="toc-text">5.2信号处理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-1%E4%BF%A1%E5%8F%B7%E4%B8%8Esignal%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.1.</span> <span class="toc-text">5.2.1信号与signal函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-2alarm%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.2.</span> <span class="toc-text">5.2.2alarm函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-3sigaction%E5%87%BD%E6%95%B0"><span class="toc-number">5.2.3.</span> <span class="toc-text">5.2.3sigaction函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-4%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E9%97%AE%E9%A2%98"><span class="toc-number">5.2.4.</span> <span class="toc-text">5.2.4复制文件描述符的问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-3%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">5.3.</span> <span class="toc-text">5.3进程间的通信</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">6.</span> <span class="toc-text">6.I&#x2F;O复用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#6-1-Select%E5%87%BD%E6%95%B0"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 Select函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">7.</span> <span class="toc-text">7多种I&#x2F;O函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#7-1-fcntl%E5%87%BD%E6%95%B0"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 fcntl函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-2-readv-writev%E5%87%BD%E6%95%B0"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 readv&amp;writev函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-1-writev%E5%87%BD%E6%95%B0"><span class="toc-number">7.2.1.</span> <span class="toc-text">7.2.1 writev函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-2-readv%E5%87%BD%E6%95%B0"><span class="toc-number">7.2.2.</span> <span class="toc-text">7.2.2 readv函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">8.</span> <span class="toc-text">8.多播与广播</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#8-1-%E5%A4%9A%E6%92%AD"><span class="toc-number">8.1.</span> <span class="toc-text">8.1 多播</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8-2-%E5%B9%BF%E6%92%AD"><span class="toc-number">8.2.</span> <span class="toc-text">8.2 广播</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">9.</span> <span class="toc-text">9.标准I&#x2F;O函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#9-1fdopen%E5%87%BD%E6%95%B0"><span class="toc-number">9.1.</span> <span class="toc-text">9.1fdopen函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-2-fileno%E5%87%BD%E6%95%B0"><span class="toc-number">9.2.</span> <span class="toc-text">9.2 fileno函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">10.</span> <span class="toc-text">10分离I&#x2F;O流</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#10-1-%E6%96%87%E4%BB%B6%E6%8F%8F%E8%BF%B0%E7%AC%A6%E7%9A%84%E5%A4%8D%E5%88%B6%E5%92%8C%E5%8D%8A%E5%85%B3%E9%97%AD"><span class="toc-number">10.1.</span> <span class="toc-text">10.1 文件描述符的复制和半关闭</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">11.</span> <span class="toc-text">11.优于select的epoll</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-1epoll-create%E5%87%BD%E6%95%B0"><span class="toc-number">11.1.</span> <span class="toc-text">11.1epoll_create函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-2epoll-ctl%E5%87%BD%E6%95%B0"><span class="toc-number">11.2.</span> <span class="toc-text">11.2epoll_ctl函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-2pthread-join%E5%87%BD%E6%95%B0"><span class="toc-number">11.3.</span> <span class="toc-text">12.2pthread_join函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-3-%E4%B8%B4%E7%95%8C%E5%8C%BA"><span class="toc-number">11.4.</span> <span class="toc-text">12.3 临界区</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-1%E4%BA%92%E6%96%A5%E9%87%8F"><span class="toc-number">11.4.1.</span> <span class="toc-text">12.3.1互斥量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-2%E4%BF%A1%E5%8F%B7%E9%87%8F"><span class="toc-number">11.4.2.</span> <span class="toc-text">12.3.2信号量</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-4%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%94%80%E6%AF%81"><span class="toc-number">11.5.</span> <span class="toc-text">12.4线程的销毁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">12.</span> <span class="toc-text">13.线程共享区域</span></a></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">13.</span> <span class="toc-text">13.Windows平台下线程的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#13-1-CreateThread%E5%87%BD%E6%95%B0"><span class="toc-number">13.1.</span> <span class="toc-text">13.1 CreateThread函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-2-beginthreadex%E5%87%BD%E6%95%B0"><span class="toc-number">13.2.</span> <span class="toc-text">13.2 _beginthreadex函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-3%E9%AA%8C%E8%AF%81%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1signaled%E7%8A%B6%E6%80%81%E5%87%BD%E6%95%B0"><span class="toc-number">13.3.</span> <span class="toc-text">13.3验证内核对象signaled状态函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">14.</span> <span class="toc-text">14.Windows中的线程同步</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#14-1%E5%9F%BA%E4%BA%8ECRITICAL-SECTION%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-number">14.1.</span> <span class="toc-text">14.1基于CRITICAL_SECTION的同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-2%E5%9F%BA%E4%BA%8E%E4%BA%92%E6%96%A5%E9%87%8F-Mutual-Exclusion-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-number">14.2.</span> <span class="toc-text">14.2基于互斥量(Mutual Exclusion)对象的同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-3%E5%9F%BA%E4%BA%8E%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-number">14.3.</span> <span class="toc-text">14.3基于信号量对象的同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-4%E5%9F%BA%E4%BA%8E%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-number">14.4.</span> <span class="toc-text">14.4基于事件对象的同步</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-4%E5%86%85%E6%A0%B8%E5%AF%B9%E8%B1%A1%E7%9A%84%E9%94%80%E6%AF%81"><span class="toc-number">14.5.</span> <span class="toc-text">14.4内核对象的销毁</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">15.</span> <span class="toc-text">15.异步通知I&#x2F;0模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#15-1-WSAEventSelect%E5%87%BD%E6%95%B0"><span class="toc-number">15.1.</span> <span class="toc-text">15.1 WSAEventSelect函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-2-manual-reset%E6%A8%A1%E5%BC%8F%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B6%E4%BB%96%E5%88%9B%E5%BB%BA%E6%96%B9%E6%B3%95%E4%BB%A5%E5%8F%8A%E9%94%80%E6%AF%81"><span class="toc-number">15.2.</span> <span class="toc-text">15.2 manual_reset模式事件对象的其他创建方法以及销毁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-3%E9%AA%8C%E8%AF%81%E6%98%AF%E5%90%A6%E5%8F%91%E7%94%9F%E4%BA%8B%E4%BB%B6"><span class="toc-number">15.3.</span> <span class="toc-text">15.3验证是否发生事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-4-%E5%8C%BA%E5%88%86%E4%BA%8B%E4%BB%B6%E7%B1%BB%E5%9E%8B"><span class="toc-number">15.4.</span> <span class="toc-text">15.4 区分事件类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">16.</span> <span class="toc-text">16.重叠I&#x2F;O模型</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#16-1%E5%88%9B%E5%BB%BA%E9%87%8D%E5%8F%A0I-O%E5%A5%97%E6%8E%A5%E5%AD%97"><span class="toc-number">16.1.</span> <span class="toc-text">16.1创建重叠I&#x2F;O套接字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-2WSASend%E5%87%BD%E6%95%B0%C2%B7"><span class="toc-number">16.2.</span> <span class="toc-text">16.2WSASend函数·</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-3WSAGetOverlappedResult%E5%87%BD%E6%95%B0"><span class="toc-number">16.3.</span> <span class="toc-text">16.3WSAGetOverlappedResult函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-4WSARecv%E5%87%BD%E6%95%B0"><span class="toc-number">16.4.</span> <span class="toc-text">16.4WSARecv函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-5-%E9%87%8D%E5%8F%A0I-O%E7%9A%84I-O%E5%AE%8C%E6%88%90%E7%A1%AE%E8%AE%A4"><span class="toc-number">16.5.</span> <span class="toc-text">16.5 重叠I&#x2F;O的I&#x2F;O完成确认</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-1-%E4%BD%BF%E7%94%A8%E4%BA%8B%E4%BB%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">16.5.1.</span> <span class="toc-text">16.5.1 使用事件对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-5-2-%E4%BD%BF%E7%94%A8Completion-Routine%E5%87%BD%E6%95%B0"><span class="toc-number">16.5.2.</span> <span class="toc-text">16.5.2 使用Completion Routine函数</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link"><span class="toc-number">17.</span> <span class="toc-text">17.IOCP</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#17-1%E5%88%9B%E5%BB%BA%E5%AE%8C%E6%88%90%E7%AB%AF%E5%8F%A3%E5%AF%B9%E8%B1%A1"><span class="toc-number">17.1.</span> <span class="toc-text">17.1创建完成端口对象</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-2%E7%A1%AE%E8%AE%A4%E5%AE%8C%E6%88%90%E7%AB%AF%E5%8F%A3%E5%AF%B9%E8%B1%A1%E5%B7%B2%E5%AE%8C%E6%88%90%E7%9A%84I-O%E5%92%8C%E7%BA%BF%E7%A8%8B%E7%9A%84I-O%E5%A4%84%E7%90%86"><span class="toc-number">17.2.</span> <span class="toc-text">17.2确认完成端口对象已完成的I&#x2F;O和线程的I&#x2F;O处理</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/01/26/%E4%B9%98%E7%A7%AF%E5%B0%8F%E4%BA%8Ek%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/" title="乘积小于k的子数组"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/wallpaper/images/j5zlom.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="乘积小于k的子数组"/></a><div class="content"><a class="title" href="/2025/01/26/%E4%B9%98%E7%A7%AF%E5%B0%8F%E4%BA%8Ek%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/" title="乘积小于k的子数组">乘积小于k的子数组</a><time datetime="2025-01-26T05:53:03.000Z" title="发表于 2025-01-26 13:53:03">2025-01-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/24/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/" title="滑动窗口-长度最小的子数组"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/wallpaper/images/p8qp3m.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="滑动窗口-长度最小的子数组"/></a><div class="content"><a class="title" href="/2025/01/24/%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3-%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84/" title="滑动窗口-长度最小的子数组">滑动窗口-长度最小的子数组</a><time datetime="2025-01-24T02:17:32.000Z" title="发表于 2025-01-24 10:17:32">2025-01-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/23/%E6%8E%A5%E9%9B%A8%E6%B0%B4/" title="接雨水"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/wallpaper/images/gjm2dd.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="接雨水"/></a><div class="content"><a class="title" href="/2025/01/23/%E6%8E%A5%E9%9B%A8%E6%B0%B4/" title="接雨水">接雨水</a><time datetime="2025-01-23T08:37:29.000Z" title="发表于 2025-01-23 16:37:29">2025-01-23</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/22/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/" title="三数之和"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/wallpaper/images/y8367l.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="三数之和"/></a><div class="content"><a class="title" href="/2025/01/22/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C/" title="三数之和">三数之和</a><time datetime="2025-01-22T02:58:59.000Z" title="发表于 2025-01-22 10:58:59">2025-01-22</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/01/22/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0Java%E7%89%88/" title="算法实现Java版"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-lazy-src="/wallpaper/images/6og3lq.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="算法实现Java版"/></a><div class="content"><a class="title" href="/2025/01/22/%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0Java%E7%89%88/" title="算法实现Java版">算法实现Java版</a><time datetime="2025-01-22T02:45:20.000Z" title="发表于 2025-01-22 10:45:20">2025-01-22</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url(/wallpaper/images/6og3lq.png);"><div id="footer-wrap"><div class="copyright">&copy;2025 By 王建</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener external nofollow noreferrer" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div><div class="footer_custom_text">Hi, welcome to my <a href="https://kunagisatomolove.github.io/">blog</a>!</div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">简</button><button id="darkmode" type="button" title="日间和夜间模式切换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="前往评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script src="https://cdn.jsdelivr.net/npm/node-snackbar/dist/snackbar.min.js"></script><script>(() => {
  const panguFn = () => {
    if (typeof pangu === 'object') pangu.autoSpacingPage()
    else {
      btf.getScript('https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js')
        .then(() => {
          pangu.autoSpacingPage()
        })
    }
  }

  const panguInit = () => {
    if (false){
      GLOBAL_CONFIG_SITE.isPost && panguFn()
    } else {
      panguFn()
    }
  }

  btf.addGlobalFn('pjaxComplete', panguInit, 'pangu')
  document.addEventListener('DOMContentLoaded', panguInit)
})()</script><div class="js-pjax"><script>(async () => {
  const showKatex = () => {
    document.querySelectorAll('#article-container .katex').forEach(el => el.classList.add('katex-show'))
  }

  if (!window.katex_js_css) {
    window.katex_js_css = true
    await btf.getCSS('https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css')
    if (false) {
      await btf.getScript('https://cdn.jsdelivr.net/npm/katex/dist/contrib/copy-tex.min.js')
    }
  }

  showKatex()
})()</script><script>(() => {
  const runMermaid = ele => {
    window.loadMermaid = true
    const theme = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'default'

    ele.forEach((item, index) => {
      const mermaidSrc = item.firstElementChild
      const mermaidThemeConfig = `%%{init:{ 'theme':'${theme}'}}%%\n`
      const mermaidID = `mermaid-${index}`
      const mermaidDefinition = mermaidThemeConfig + mermaidSrc.textContent

      const renderFn = mermaid.render(mermaidID, mermaidDefinition)
      const renderMermaid = svg => {
        mermaidSrc.insertAdjacentHTML('afterend', svg)
      }

      // mermaid v9 and v10 compatibility
      typeof renderFn === 'string' ? renderMermaid(renderFn) : renderFn.then(({ svg }) => renderMermaid(svg))
    })
  }

  const codeToMermaid = () => {
    const codeMermaidEle = document.querySelectorAll('pre > code.mermaid')
    if (codeMermaidEle.length === 0) return

    codeMermaidEle.forEach(ele => {
      const preEle = document.createElement('pre')
      preEle.className = 'mermaid-src'
      preEle.hidden = true
      preEle.textContent = ele.textContent
      const newEle = document.createElement('div')
      newEle.className = 'mermaid-wrap'
      newEle.appendChild(preEle)
      ele.parentNode.replaceWith(newEle)
    })
  }

  const loadMermaid = () => {
    if (true) codeToMermaid()
    const $mermaid = document.querySelectorAll('#article-container .mermaid-wrap')
    if ($mermaid.length === 0) return

    const runMermaidFn = () => runMermaid($mermaid)
    btf.addGlobalFn('themeChange', runMermaidFn, 'mermaid')
    window.loadMermaid ? runMermaidFn() : btf.getScript('https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js').then(runMermaidFn)
  }

  btf.addGlobalFn('encrypt', loadMermaid, 'mermaid')
  window.pjax ? loadMermaid() : document.addEventListener('DOMContentLoaded', loadMermaid)
})()</script><script>(() => {
  const isShuoshuo = GLOBAL_CONFIG_SITE.isShuoshuo
  const option = null

  const getCount = () => {
    const countELement = document.getElementById('twikoo-count')
    if(!countELement) return
    twikoo.getCommentsCount({
      envId: 'https://wj-blog.zeabur.app',
      region: '',
      urls: [window.location.pathname],
      includeReply: false
    }).then(res => {
      countELement.textContent = res[0].count
    }).catch(err => {
      console.error(err)
    })
  }

  const init = (el = document, path = location.pathname) => {
    twikoo.init({
      el: el.querySelector('#twikoo-wrap'),
      envId: 'https://wj-blog.zeabur.app',
      region: '',
      onCommentLoaded: () => {
        btf.loadLightbox(document.querySelectorAll('#twikoo .tk-content img:not(.tk-owo-emotion)'))
      },
      ...option,
      path: isShuoshuo ? path : (option && option.path) || path
    })

    

    isShuoshuo && (window.shuoshuoComment.destroyTwikoo = () => {
      if (el.children.length) {
        el.innerHTML = ''
        el.classList.add('no-comment')
      }
    })
  }

  const loadTwikoo = (el, path) => {
    if (typeof twikoo === 'object') setTimeout(() => init(el, path), 0)
    else btf.getScript('https://cdn.jsdelivr.net/npm/twikoo/dist/twikoo.all.min.js').then(() => init(el, path))
  }

  if (isShuoshuo) {
    'Twikoo' === 'Twikoo'
      ? window.shuoshuoComment = { loadComment: loadTwikoo }
      : window.loadOtherComment = loadTwikoo
    return
  }

  if ('Twikoo' === 'Twikoo' || !false) {
    if (false) btf.loadComment(document.getElementById('twikoo-wrap'), loadTwikoo)
    else loadTwikoo()
  } else {
    window.loadOtherComment = loadTwikoo
  }
})()</script></div><script defer="defer" id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful = true;
POWERMODE.shake = false;
POWERMODE.mobile = false;
document.body.addEventListener('input', POWERMODE);
</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><div id="algolia-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="search-wrap"><div id="algolia-search-input"></div><hr/><div id="algolia-search-results"><div id="algolia-hits"></div><div id="algolia-pagination"></div><div id="algolia-info"><div class="algolia-stats"></div><div class="algolia-poweredBy"></div></div></div></div></div><div id="search-mask"></div><script src="https://cdn.jsdelivr.net/npm/algoliasearch/dist/lite/builds/browser.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instantsearch.js/dist/instantsearch.production.min.js"></script><script src="/js/search/algolia.js"></script></div></div></body></html>